	
	1. Что подразумевается под тестовой средой?

Тестовая среда (среда тестирования) — это комбинация аппаратной и программной среды, в которой будут выполняться тесты. Среда поддерживает выполнение теста с настроенным оборудованием, программным обеспечением и сетью.

Тестовая среда (испытательный стенд) настраивается в соответствии с требованиями тестируемого приложения. В некоторых случаях испытательный стенд может представлять собой комбинацию тестовой среды и тестовых данных, которые он использует.

Настройка правильной среды тестирования гарантирует успех тестирования программного обеспечения.

В тестовой среде работают тестировщики. Здесь тестировщики тестируют новые билды, проверяют функционал, проводят регрессионные проверки, воспроизводят ошибки. 

Эта среда появляется во время начала динамического тестирования.

	
	2. В чем отличие build от release?

Билд это номер, даваемый ПО при передаче от разработчиков тестировщикам. 

Релиз — это номер, даваемый ПО при передаче конечному пользователю.

	
	3. Основные фазы тестирования.

	Основными фазами тестирования являются:

	– модульное тестирование;
	– интеграционное тестирование;
	– системное тестирование (в том числе адаптационное, функциональное и нагрузочное);
	– регрессионное тестирование;
	– приемочное тестирование.

	На стадии модульного тестирования достаточно просто выявляются просчеты в логике построения модуля и/или реализации алгоритмов, ошибки, связанные с неправильным использованием локальных ресурсов, а также ошибки в локальных переменных.

	Следующим этапом явлется интеграционное тестирование. Оно проходит в несколько стадий и заключается в тестировании частей системы, состоящих из двух и большего количества модулей. 

	Третьим этапом является системное тестирование, которое существенным образом отличается от модульного и интеграционного. Оно рассматривает систему как черный ящик и работает исключительно с пользовательскими интерфейсами. 

Основной целью системного тестирования является проверка стабильности и корректности работы системы, а также соответствия функциональностей системы спецификациям, указанным в сопроводительных документах, 

проверяется работа системы на базе различных операционных систем и аппаратного обеспечения. Исследуется производительность тестируемого программного обеспечения.

	Основной целью регрессионного тестирования является проверка того, что в результате внесения изменений в программный код зафиксированные ранее ошибки исправлены, а новые не появляются. 

Для регрессионного тестирования используется специально разработанный набор тестов, из которого каждый раз выбираются те тесты, которые позволяют обнаружить появление новых ошибок с наибольшей вероятностью.

	Приемочное тестирование — тестирование интегральной функциональности системы на соответствие требованиям заказчика. Планируется с участием представителей заказчика. 

Проводится на заключительном этапе с целью удостовериться в том, что система работает так, как и ожидалось, все необходимые формы, процедуры присутствуют и функционируют нормально. 

Данное тестирование является высокоуровневой проверкой отсутствия пробелов в функциональности системы.

Положительные результаты бизнес-тестирования означают, что все компоненты системы работоспособны и включены в данную версию продукта.


	4. Что такое импакт анализ?

Impact Analysis (импакт анализ) - это исследование, которое позволяет указать затронутые места (affected areas) в проекте при разработке новой или изменении старой функциональности, а также определить, насколько значительно они были затронуты. 

Затронутые области требуют большего внимания во время проведения регрессионного тестирования. 

Импакт анализ может быть полезным в следующих случаях:

 	* есть изменения в требованиях;

 	* получен запрос на внесение изменений в продукт;

 	* ожидается внедрение нового модуля или функциональности в существующий продукт;

 	* каждый раз, когда есть изменения в существующих модулях или функциональностях продукта.

В настоящее время продукты становятся все более большими и комплексными, а компоненты все чаще зависят друг от друга. 

Изменение строчки кода в таком проекте может "сломать" абсолютно все. Информация о взаимосвязи и взаимном влиянии изменений могут помочь QA:

	- сфокусироваться на тестировании функциональности, где изменения были представлены;

	- принять во внимание части проекта, которые были затронуты изменениями и, возможно, пострадали;

	- не тратить время на тестирование тех частей проекта, которые не были затронуты изменениями.


	5. Критерии выбора тестов.

Требования к идеальному критерию тестирования:

	Критерий должен быть достаточным, т.е. показывать, когда некоторое конечное множество тестов достаточно для тестирования данной программы.
	Критерий должен быть полным, т.е. в случае ошибки должен существовать тест из множества тестов, удовлетворяющих критерию, который раскрывает ошибку.
	Критерий должен быть надежным, т.е. любые два множества тестов, удовлетворяющих ему, одновременно должны раскрывать или не раскрывать ошибки программы.
	Критерий должен быть легко проверяемым, например вычисляемым на тестах.

Для нетривиальных классов программ в общем случае не существует полного и надежного критерия, зависящего от программ или спецификаций. 
Поэтому мы стремимся к идеальному общему критерию через реальные частные. 
	
Классы критериев:

Структурные критерии используют информацию о структуре программы (критерии так называемого "белого ящика").
Функциональные критерии формулируются в описании требований к программному изделию ( критерии так называемого "черного ящика" ).
Критерии стохастического тестирования формулируются в терминах проверки наличия заданных свойств у тестируемого приложения, средствами проверки некоторой статистической гипотезы.
Мутационные критерии ориентированы на проверку свойств программного изделия на основе подхода Монте-Карло.

	Структурные критерии используют модель программы в виде "белого ящика", что предполагает знание исходного текста программы или спецификации программы в виде потокового графа управления. 
Структурная информация понятна и доступна разработчикам подсистем и модулей приложения, поэтому данный класс критериев часто используется на этапах модульного и интеграционного тестирования (Unit testing, Integration testing). 
Структурные критерии базируются на основных элементах УГП (Управляющий граф программы), операторах, ветвях и путях.
Условие критерия тестирования команд (критерий С0) - набор тестов в совокупности должен обеспечить прохождение каждой команды не менее одного раза. 
Это слабый критерий, он, как правило, используется в больших программных системах, где другие критерии применить невозможно.
Условие критерия тестирования ветвей (критерий С1) - набор тестов в совокупности должен обеспечить прохождение каждой ветви не менее одного раза. 
Это достаточно сильный и при этом экономичный критерий, поскольку множество ветвей в тестируемом приложении конечно и не так уж велико. 
Данный критерий часто используется в системах автоматизации тестирования.
Условие критерия тестирования путей (критерий С2) - набор тестов в совокупности должен обеспечить прохождение каждого пути не менее 1 раза. 
сли программа содержит цикл (в особенности с неявно заданным числом итераций), то число итераций ограничивается константой (часто - 2, или числом классов выходных путей).
Структурные критерии не проверяют соответствие спецификации, если оно не отражено в структуре программы. 
Поэтому при успешном тестировании программы по критерию C2 мы можем не заметить ошибку, связанную с невыполнением некоторых условий спецификации требований. 

	Функциональный критерий - важнейший для программной индустрии критерий тестирования. Он обеспечивает, прежде всего, контроль степени выполнения требований заказчика в программном продукте. 
Поскольку требования формулируются к продукту в целом, они отражают взаимодействие тестируемого приложения с окружением. 
При функциональном тестировании преимущественно используется модель "черного ящика". 
Проблема функционального тестирования - это, прежде всего, трудоемкость; дело в том, что документы, фиксирующие требования к программному изделию (Software requirement specification, Functional specification и т.п.), 
как правило, достаточно объемны, тем не менее, соответствующая проверка должна быть всеобъемлющей. 
Ниже приведены частные виды функциональных критериев:
	Тестирование пунктов спецификации - набор тестов в совокупности должен обеспечить проверку каждого тестируемого пункта не менее одного раза. 
Спецификация требований может содержать сотни и тысячи пунктов требований к программному продукту и каждое из этих требований при тестировании должно быть проверено в соответствии с критерием не менее чем одним тестом.
	Тестирование классов входных данных - набор тестов в совокупности должен обеспечить проверку представителя каждого класса входных данных не менее одного раза. 
При создании тестов классы входных данных сопоставляются с режимами использования тестируемого компонента или подсистемы приложения, что заметно сокращает варианты перебора, учитываемые при разработке тестовых наборов. 
Следует заметить, что перебирая в соответствии с критерием величины входных переменных (например, различные файлы - источники входных данных), мы вынуждены применять мощные тестовые наборы. 
Действительно, наряду с ограничениями на величины входных данных, существуют ограничения на величины входных данных во всевозможных комбинациях, в том числе проверка реакций системы на появление ошибок в значениях или структурах входных данных. 
Учет этого многообразия - процесс трудоемкий, что создает сложности для применения критерия.
	Тестирование правил - набор тестов в совокупности должен обеспечить проверку каждого правила, если входные и выходные значения описываются набором правил некоторой грамматики. 
Следует заметить, что грамматика должна быть достаточно простой, чтобы трудоемкость разработки соответствующего набора тестов была реальной (вписывалась в сроки и штат специалистов, выделенных для реализации фазы тестирования).
	Тестирование классов выходных данных - набор тестов в совокупности должен обеспечить проверку представителя каждого выходного класса, при условии, 
что выходные результаты заранее расклассифицированы, причем отдельные классы результатов учитывают, в том числе, ограничения на ресурсы или на время (time out). 
При создании тестов классы выходных данных сопоставляются с режимами использования тестируемого компонента или подсистемы, что заметно сокращает варианты перебора, учитываемые при разработке тестовых наборов.
	Тестирование функций - набор тестов в совокупности должен обеспечить проверку каждого действия, реализуемого тестируемым модулем, не менее одного раза. 
Очень популярный на практике критерий, который, однако, не обеспечивает покрытия части функциональности тестируемого компонента, связанной со структурными и поведенческими свойствами, 
описание которых не сосредоточено в отдельных функциях (т.е. описание рассредоточено по компоненту). Критерий тестирования функций объединяет отчасти особенности структурных и функциональных критериев. 
Он базируется на модели "полупрозрачного ящика", где явно указаны не только входы и выходы тестируемого компонента, но также состав и структура используемых методов (функций, процедур) и классов.
	
	Комбинированные критерии для программ и спецификаций - набор тестов в совокупности должен обеспечить проверку всех комбинаций непротиворечивых условий программ и спецификаций не менее одного раза. 
При этом все комбинации непротиворечивых условий надо подтвердить, а условия противоречий следует обнаружить и ликвидировать.
	
	Стохастическое тестирование применяется при тестировании сложных программных комплексов - когда набор детерминированных тестов (X,Y) имеет громадную мощность. 

	Мутационный критерий (класс IV). Постулируется, что профессиональные программисты пишут сразу почти правильные программы, 
отличающиеся от правильных мелкими ошибками или описками типа - перестановка местами максимальных значений индексов в описании массивов, 
ошибки в знаках арифметических операций, занижение или завышение границы цикла на 1 и т.п. Предлагается подход, позволяющий на основе мелких ошибок оценить общее число ошибок, оставшихся в программе. 
Подход базируется на следующих понятиях: Мутации - мелкие ошибки в программе. Мутанты - программы, отличающиеся друг от друга мутациями . 
Метод мутационного тестирования - в разрабатываемую программу P вносят мутации, т.е. искусственно создают программы-мутанты P1, P2... 
Затем программа P и ее мутанты тестируются на одном и том же наборе тестов (X,Y). Если на наборе (X,Y) подтверждается правильность программы P и, кроме того, выявляются все внесенные в программы-мутанты ошибки, 
то набор тестов (X,Y) соответствует мутационному критерию, а тестируемая программа объявляется правильной. 
Если некоторые мутанты не выявили всех мутаций, то надо расширять набор тестов (X,Y) и продолжать тестирование.

	
	6. Принципы тестирования

	1. Тестирование показывает наличие дефектов

Тестирование может показать наличие дефектов в программе, но не доказать их отсутствие. Тем не менее, важно составлять тест-кейсы, которые будут находить как можно больше багов. 
Таким образом, при должном тестовом покрытии, тестирование позволяет снизить вероятность наличия дефектов в программном обеспечении. 
В то же время, даже если дефекты не были найдены в процессе тестирования, нельзя утверждать, что их нет.

	2. Исчерпывающее тестирование невозможно

Невозможно провести исчерпывающее тестирование, которое бы покрывало все комбинации пользовательского ввода и состояний системы, за исключениям совсем уж примитивных случаев. 
Вместо этого необходимо использовать анализ рисков и расстановку приоритетов, что позволит более эффективно распределять усилия по обеспечению качества ПО.

	3. Раннее тестирование

Тестирование должно начинаться как можно раньше в жизненном цикле разработки программного обеспечения, и его усилия  должны быть сконцентрированы на определенных целях.

	4. Скопление дефектов

Разные модули системы могут содержать разное количество дефектов – то есть, плотность скопления дефектов в разных элементах программы может отличаться. 
Усилия по тестированию должны распределяться пропорционально фактической плотности дефектов. В основном, большую часть критических дефектов находят в ограниченном количестве модулей. 
Это проявление принципа Парето: 80% проблем содержатся в 20% модулей.

	5. Парадокс пестицида

Прогоняя одни и те же тесты вновь и вновь, тестировщики сталкиваются с тем, что они находят все меньше новых ошибок. 
Поскольку система эволюционирует, многие из ранее найденных дефектов исправляют и старые тест-кейсы больше не срабатывают.

Чтобы преодолеть этот парадокс, необходимо периодически вносить изменения в используемые наборы тестов, рецензировать и корректировать их с тем, 
чтобы они отвечали новому состоянию системы и позволяли находить как можно большее количество дефектов.

	6. Тестирование зависит от контекста

Выбор методологии, техники и типа тестирования будет напрямую зависеть от природы самой программы. 
Например, программное обеспечение для медицинских нужд требует гораздо более строгой и тщательной проверки, чем, скажем, компьютерная игра. 
Из тех же соображений, сайт с большой посещаемостью должен пройти через серьезное тестирование производительности, чтобы показать возможность работы в условиях высокой нагрузки.

	7. Заблуждение об отсутствии ошибок.

Тот факт, что тестирование не обнаружило дефектов, еще не значит, что программа готова к релизу. 
Нахождение и исправление дефектов будут не важны, если система окажется неудобной в использовании, и не будет удовлетворять ожиданиям и потребностям пользователя.
	
	
	7. Что такое независимое тестирование?

	Независимое тестирование соответствует независимой команде, которая участвует в тестировании, отличном от разработчика, чтобы избежать предвзятости автора и часто более эффективна в поиске дефектов и сбоев.	

	Иногда следует нанять независимую организацию по тестированию, которая тщательно проверит продукт на наличие сбоев, готовя его к развертыванию.  
	
	Тестирование по уровням независимости:

Программист тестирует свой код 
Тестирование проводится другим программистом в организации
Внутренняя команда тестирования 
Независимая организация тестирования

Когда программист проверяет свой код.

Тестирование проводится другим программистом в организации: компромисс - это найти кого-то в организации. Это может быть какой-то другой программист, который участвует в некоторых других проектах. 
Это дает определенный уровень независимости. Но проблема возникает из-за того же manager. Менеджер может попросить программиста пропустить некоторые тесты, когда есть ограничения по времени. 
Это приведет к неполному тестированию продукта. Кроме того, если попросить других разработчиков провести тестирование, это приведет к развертыванию различных ресурсов в одном проекте. 
Это будет вредно для всей работы организации. 

Внутренняя команда тестирования: Наличие другой внутренней команды - это хорошее решение. 
Но поскольку они будут в организации, на них будут влиять ограничительные сроки. 
Кроме того, это будет дорого поддерживать внутреннюю команду. Это приведет к большим бюджетным и ресурсным ограничениям для команды. 
Команда может иметь доступ к ограниченным инструментам и программному обеспечению, таким образом, не отвечая требованиям всех проектов. 
Среда тестирования также будет варьироваться в зависимости от количества пользователей и числа выполненных интеграций. 
Затем тестирование будет проводиться в спешном порядке, что приведет к упущению некоторых ошибок, которые могут появиться после выпуска продукта. 

Решение, которое позаботится обо всех этих недостатках, - «Независимое тестирование». 
Почему независимое тестирование? Независимые тестирующие организации изучат все аспекты продукции. 
Они работают с мышлением поиска недостатков и ошибок. Они не будут использовать ярлыки в процессе тестирования. 
И поскольку они не были частью процесса разработки, они будут проводить тесты на нейтральной основе, чтобы прежние интересы не мешали процессу тестирования. 
Мысль о поиске максимальных «точек останова» пойдет на пользу вашему продукту. 
Почти все сторонние тестирующие организации предоставят вам подробные отчеты об ошибках и предложат корректирующие меры. 


	8. Что такое тестирование со сдвигом влево?

	В попытке перенести тестирование на более ранний этап жизненного цикла разработки при одновременном улучшении показателей качества, 
задачи смещаются влево в схеме жизненного цикла разработки ПО. 
	По возможности, тестирование должно проводиться с самого начала фазы проектирования, чтобы построить соответствующую стратегию тестирования. 
Проще говоря, это подход к тестированию программного обеспечения и тестированию системы, при котором тестирование выполняется на более раннем этапе жизненного цикла. 

Ключевые преимущества:
	* Сокращение затрат 
 	* Более высокое качество
 	* Повышение эффективности 
 	* Конкурентные преимущества


	9. Почему тестирование делится на отдельные этапы?

	* Каждый этап испытаний имеет свое назначение 
	* Проще управлять поэтапно 
	* Мы можем запустить разные тесты в разных средах 
	* Производительность и качество тестирования улучшаются с помощью поэтапного тестирования


	10. Этапы тестирования.

	 Всего принято выделять 7 этапов тестирования:

1 Работа с требованиями. Знакомство с требованиями заказчика, что должен из себя представлять итоговый продукт, обсуждение.
2 Разработка стратегии тестирования. Оценка сроков тестирования, выявление среды тестирования, объединение всей информации, полученной при работе с требованиями.
3 Создание тестовой документации. Написание сценариев, которые позволят проверить функционал.
4 Тестирование прототипа. Тестирование основного функционала продукта, корректировка целей, добавление фичей.
5 Основное тестирование. Выполнение общей проверки продукта.
6 Стабилизация. На данном этапе происходит работа над устранением багов.
7 Эксплуатация. Проводится регресс-тестирование, устранение ошибок, которые нашел конечный пользователь.
Прежде, чем переходить к описанию каждого цикла тестирования, необходимо запомнить важное правило: переход к следующему этапу допустим лишь после полного завершения работы на предыдущем.


	11. Как тестировать продукт, если нет требований.	 

	Использование неформальных техник тестирования:

	– Ad hoc тестирование

	– исследовательское (exploratory) тестирование.

Свободное тестирование (ad-hoc testing) – это вид тестирования, который выполняется без подготовки к тестированию продукта, без определения ожидаемых результатов, проектирования тестовых сценариев. 
Это неформальное, импровизационное тестирование. Оно не требует никакой документации, планирования, процессов, которых следует придерживаться при выполнении тестирования. 
Такой способ тестирования в большинстве случаев дает большее количество заведенных отчётов об ошибке.  
Это обусловлено тем, что тестировщик на первых шагах приступает к тестированию основной функциональной 
части продукта и выполняет как позитивные, так и негативные варианты возможных сценариев.

Чаще всего такое тестирование выполняется, когда владелец продукта не обладает конкретными целями, проектной документацией и ранее поставленными задачами. 
При этом тестировщик полагается на свое общее представление о продукте, сравнение с похожими продуктами, собственный опыт. 
Однако при тестировании ad-hoc имеет смысл владеть общей информацией о продукте, особенно если проект очень сложный и большой. 
Поэтому нужно хорошее представление о целях проекта, его назначении и основных функциях и возможностях. А дальше уже можно приступать к ad-hoc тестированию.

Исследовательское тестирование (exploratory testing) — это одновременное изучение программного продукта, проектирование тестов и их выполнение. 
Это неформальный метод проектирования тестов, при котором тестировщик активно контролирует проектирование тестов в то время, как эти тесты выполняются, 
и использует полученную во время тестирования информацию для проектирования новых тестов.
Если каждый следующий тест, который выполняет тестировщик, выбирается по результатам предыдущего теста, это означает, что мы используем исследовательское тестирование.

Главное, что нужно помнить об исследовательском тестировании, это то, что само по себе оно не является методикой тестирования. 
Это, скорее, подход, который можно применить к любому виду тестирования. 
Еще один важный момент заключается в том, что исследовательское тестирование – это не только выполнение тестов. 
Тестировщики могут применять исследовательский подход и при разработке новых тестов в начале итерации, и при анализе уже завершенных тестов. 
Также, исследовательское тестирование не должно выполняться небрежно, в спешке и без подготовки. 
Исследовательский подход может требовать очень тщательной и длительной подготовки к определенным тестам, а накопленные за многие годы знания и умения тестировщика, применяющего данный подход, – это часто невидимая, но важная форма подготовки. 
Исследовательское тестирование может проводиться вручную, а может осуществляться с широким применением средств автоматизации, т.е. любых вспомогательных инструментов тестирования.

Когда следует применять исследовательское тестирование?

	Самые распространенные случаи:

когда нужно обеспечить быструю обратную связь для нового продукта или новой функциональности продукта;
когда нужно быстро ознакомиться с продуктом;
когда уже были проведены основные виды тестирования и время позволяет разнообразить методы тестирования;
когда нужно найти дефект, локализованный в определенном модуле в кратчайшие сроки;
когда проверяется работа другого специалиста по тестированию;
когда нужно изучить состояние конкретного риска для принятия решения о необходимости покрытия конкретной области  тестами.

Вывод

Описанные выше методы тестирования имеют основательные сходства и различия, поэтому стоит разделять эти две популярные методики в рамках  тестирования. 
Разница между ad-hoc и exploratory testing в том, что теоретически, ad-hoc может провести кто угодно, а для проведения exploratory необходимо мастерство и владение определёнными техниками. 
При этом, определённые техники – это не только техники тестирования.

Оба метода часто используются в проектах, а также являются неотъемлемой частью знаний и опыта современного  тестировщика программного обеспечения.


	12. Как узнать, было ли создано достаточно тестов для тестирования продукта?

Матрица прослеживаемости - это понятный инструмент, который обеспечивает соответствие требований тестовым примерам. 
Когда выполнение всех Test case заканчивается успешно, это указывает на то, что код соответствует требованиям. 

Матрица прослеживаемости - это документ, который связывает любые два базовых документа, которые требуют отношения «многие ко многим» для проверки полноты отношений. 
В случае тестирования это матрица покрытия функциональных требований тест-кейсами. 
Есть даже такое понятие как Requirement based testing, которое имеет место быть, когда есть требования к продукту, на их основе составляются тест-сценарии и выполняется тестирование. 

Зачем нужна эта матрица? 

Например, для того чтобы: 

- при разработке тестов четко ориентироваться какие из требований уже покрыты тестами, а какие еще нет; 

- при выполнении тестирования ориентироваться какие из требований прошли все написанные для них тесты успешно, а какие - еще нет. 

Матрица трассировки может служить одновременно в качестве матрицы покрытия. 
Наличие такой матрицы позволяет объективно оценить, какая часть продукта покрыта тестами, а какая нет. 
Это необходимое условие, чтобы оценить, какой объем работы мы уже выполнили и что еще осталось сделать - и по части создания, и по части выполнения тестов. 
Еще одно преимущество traceability matrix – ее наглядность. Если она поддерживается в актуальном состоянии, то можно сразу увидеть "белые пятна" и сосредоточиться на них. 
Traceability matrix также позволяет сравнивать тесты между собой по критерию количества требований, которые они покрывают. 
Одни тесты могут покрывать несколько требований, другие – только одно.


	13. Что подразумевается под тестовыми данными?

Тестовые данные - это набор входных значений, необходимых для выполнения Test case. 

Тестировщики определяют данные в соответствии с требованиями. 
	
Они могут сделать это вручную или использовать инструменты генерации.

	
	14. Что такое бета-тестирование?

	Бета-тестирование - интенсивное использование почти готовой версии продукта (как правило, программного или аппаратного обеспечения) с целью выявления максимального числа ошибок в его работе 

для их последующего устранения перед окончательным выходом продукта на рынок, к массовому потребителю.

	Бета-тестирование предполагает привлечение добровольцев из числа обычных будущих пользователей продукта, которым доступна предварительная версия продукта (так называемая бета-версия).

Такими добровольцами (их называют бета-тестерами) часто движет любопытство к новому продукту — любопытство, ради удовлетворения которого они вполне согласны мириться с возможностью испытать последствия ещё не найденных (а потому и не исправленных) ошибок. 

Кроме любопытства, мотивация может быть обусловлена желанием повлиять на процесс разработки и в итоге получать более удовлетворяющий их нужды продукт и многим другим.

Кроме того, открытие бета-тестирования может использоваться как часть стратегии продвижения продукта на рынок (например, бесплатная раздача бета-версий позволяет привлечь широкое внимание потребителей к окончательной дорогостоящей версии продукта), 

а также для получения предварительных отзывов о нём от широкого круга будущих пользователей.

Бета-версия не является финальной версией продукта, поэтому разработчик не гарантирует полного отсутствия ошибок, которые могут нарушить работу компьютера и/или привести к потере данных. 

Хотя и в финальных версиях таких гарантий разработчики, как правило, не дают.

Кроме программного и аппаратного обеспечения понятие бета-версия в последнее время часто применяется к сайтам, либо к их определённым разделам или функциям. 

При этом в большинстве случаев бета-тестирование является открытым, а доработки производятся в процессе функционирования сайта.


	15. Что означает пилотное тестирование? (Pilot)

	 PILOT testing определяется как тип тестирования программного обеспечения, который проверяет компонент системы или всю систему в режиме реального времени. 

Целью пилотного теста является оценка осуществимости, времени, стоимости, риска и эффективности исследовательского проекта. 

Это тестирование проводится точно между UAT и Production. 

В пилотном тестировании выбранная группа конечных пользователей пробует тестируемую систему и предоставляет обратную связь до полного развертывания системы. 

Другими словами, это означает проведение генеральной репетиции для последующего теста на удобство использования. 

Пилотное тестирование помогает в раннем обнаружении ошибок в Системе. 

Пилотное тестирование связано с установкой системы на площадке заказчика (или в среде, моделируемой пользователем) для тестирования на предмет постоянного и регулярного использования. 

Выявленные недостатки затем отправляются команде разработчиков в виде отчетов об ошибках, и эти ошибки исправляются в следующей сборке системы. 

Во время этого процесса иногда приемочное тестирование также включается как часть тестирования на совместимость. 

Это происходит, когда система разрабатывается для замены старой. 


	16. Чем AdHock тестирование отличается от исследовательского тестирования?

	Свободное тестирование (ad-hoc testing) – это вид тестирования, который выполняется без подготовки к тестированию продукта, без определения ожидаемых результатов, проектирования тестовых сценариев. 

Это неформальное, импровизационное тестирование. Оно не требует никакой документации, планирования, процессов, которых следует придерживаться при выполнении тестирования. 

Такой способ тестирования в большинстве случаев дает большее количество заведенных отчётов об ошибке.  

Это обусловлено тем, что тестировщик на первых шагах приступает к тестированию основной функциональной части продукта и выполняет как позитивные, так и негативные варианты возможных сценариев.

	Исследовательское тестирование (exploratory testing) — это одновременное изучение программного продукта, проектирование тестов и их выполнение. 

Это неформальный метод проектирования тестов, при котором тестировщик активно контролирует проектирование тестов в то время, как эти тесты выполняются, и использует полученную во время тестирования информацию для проектирования новых тестов.

Если каждый следующий тест, который выполняет тестировщик, выбирается по результатам предыдущего теста, это означает, что мы используем исследовательское тестирование.

Главное, что нужно помнить об исследовательском тестировании, это то, что само по себе оно не является методикой тестирования. Это, скорее, подход, который можно применить к любому виду тестирования.


	17. Что такое бизнес – логика?
 
Бизнес – логика (domain) это то, что конкретная программа по задумке должна сделать. Например, в складской программе проверка на возможность отправить товар (вдруг его нет в наличии). 

Это правила, которые должны соблюдаться в данной конкретной программе, определенные бизнес-клиентом. 

Слои приложения – слой пользовательского интерфейса, слой бизнес логики (доменный слой), слой сохранения данных.


	18. Какие существуют основные виды тестирования ПО?

	Функциональные виды («Что?» - проверяет весь функционал продукта):
Функциональное тестирование (Functional testing)
Тестирование взаимодействия (Interoperability testing)

	Нефункциональное («Как?»):
Производительности (Performance)
Тестирование емкости/способностей (Capacity testing)
Стрессовое (Stress testing)
Нагрузочное (Load testing)
Объемное тестирование (Volume testing)
Выносливости (Soak/Endurance testing)
Стабильности/надежности (Stability / Reliability testing)
Шиповое (Spike)
Отказоустойчивости (Stability testing)
Масштабируемости (Scalability test)
Отказ и восстановление (Failover and Recovery testing)
Удобство пользования (Usability testing)
Тестирование установки (Installation testing)
Тестирование безопасности (Security and Access Control testing)
Конфигурационное (Configuration testing)

	Связанное с изменениями:
Регрессионное (Regression testing)
Санитарное (Sanity testing)
Дымовое (Smoke testing)
Тестирование сборки (Build Verification testing)

	Функциональное тестирование рассматривает заранее указанное поведение и основывается на анализе спецификаций функциональности компонента или системы в целом. 
Функциональные тесты основываются на функциях, выполняемых системой, и могут проводиться на всех уровнях тестирования (компонентном, интеграционном, системном, приемочном). 
Как правило, эти функции описываются в требованиях, функциональных спецификациях или в виде случаев использования системы (use cases). 
Тестирование в перспективе «требования» использует спецификацию функциональных требований к системе как основу для дизайна Test case. 
В этом случае необходимо сделать список того, что будет тестироваться, а что нет, приоритезировать требования на основе рисков (если это не сделано в документе с требованиями), а на основе этого приоритезировать тестовые сценарии. 
Это позволит сфокусироваться и не упустить при тестировании наиболее важный функционал. 
Тестирование в перспективе «бизнес-процессы» использует знание этих самых бизнес-процессов, которые описывают сценарии ежедневного использования системы. 
В этой перспективе тестовые сценарии (test scripts), как правило, основываются на случаях использования системы (use cases). 
	Преимущества функционального тестирования:
имитирует фактическое использование системы;
	Недостатки функционального тестирования:
возможность упущения логических ошибок в программном обеспечении;
вероятность избыточного тестирования.

	Тестирование взаимодействия - функциональное тестирование, проверяющее способность приложения/устройства взаимодействовать с одним и более компонентами/системами/устройствами
и включающее в себя тестирование совместимости (compatibility testing) и интеграционное тестирование (integration testing).  
ПО с хорошими характеристиками взаимодействия может быть легко интегрировано с другими системами, не требуя каких-либо серьезных модификаций. 
В этом случае, количество изменений и время, требуемое на их выполнение, могут быть использованы для измерения возможности взаимодействия. 
Например, тестирование совместимости проводится между смартфонами и планшетами для проверки передачи данных через Bluetooth. 

	Существуют разные уровни тестирования совместимости:

Аппаратное обеспечение: проверяет совместимость программного обеспечения с различными аппаратными конфигурациями. 

Операционные системы: Он проверяет ваше программное обеспечение на совместимость с различными операционными системами, такими как Windows, Mac OS и т. д. 

Программное обеспечение: проверяет ваше разработанное программное обеспечение на совместимость с другим программным обеспечением. Например, приложение MS Word должно быть совместимо с другими программами, такими как MS Outlook, MS Excel, VBA и т. д. 

Сеть: оценка производительности системы в сети с различными параметрами, такими как пропускная способность, скорость работы, емкость. 

Браузер: проверяет совместимость вашего сайта с различными браузерами, такими как Firefox, Google Chrome, Internet Explorer и т. д. 

Устройства: проверяет совместимость вашего программного обеспечения с различными устройствами, такими как устройства USB-порта, принтеры и сканеры, другие мультимедийные устройства и Bluetooth. 

Mobile: проверка совместимости вашего программного обеспечения с мобильными платформами, такими как Android, iOS и т. д. 

Версии программного обеспечения. Он проверяет совместимость вашего программного приложения с различными версиями программного обеспечения. 

Например, проверка вашего Microsoft Word на совместимость с Windows 7, Windows 7 SP1, Windows 7 SP2, Windows 7 SP3.

Существует два типа проверки версий:

Тестирование обратной совместимости предназначено для проверки поведения разработанного аппаратного / программного обеспечения с использованием более старых версий аппаратного / программного обеспечения. 

Тестирование прямой совместимости заключается в проверке поведения разработанного аппаратного / программного обеспечения с использованием более новых версий аппаратного / программного обеспечения.


	19.  Методы тестирования

Тестирование Black-Box
Методика тестирования без каких-либо знаний о внутренней работе приложения называется «черным ящиком». 
Тестер не обращает внимания на архитектуру системы и не имеет доступа к исходному коду. 
Как правило, при выполнении теста с «черным ящиком» тестер будет взаимодействовать с пользовательским интерфейсом системы, 
предоставляя входные данные и анализируя выходы, не зная, как и где обрабатываются входы.

Тестирование белого ящика
Проверка белого ящика - это подробное исследование внутренней логики и структуры кода. 
Тестирование с использованием белого ящика также называется тестированием стекла или открытым тестированием . 
Чтобы выполнить тестирование белого ящика в приложении, тестер должен знать внутреннюю работу кода.
Тестер должен заглянуть внутрь исходного кода и выяснить, какое устройство / блок кода ведет себя некорректно.

Тестирование серых ящиков
Тестирование на серой коробке - это метод тестирования приложения с ограниченным знанием внутренней работы приложения. 
При тестировании программного обеспечения фраза, чем больше вы знаете, тем лучше переносит массу при тестировании приложения.

Освоение домена системы всегда дает тестеру преимущество над кем-то с ограниченными знаниями домена. 
В отличие от тестирования черного ящика, где тестер тестирует только пользовательский интерфейс приложения; при тестировании в сером полете тестер имеет доступ к проектной документации и базе данных. 
Имея эти знания, тестер может подготовить лучшие тестовые данные и сценарии тестирования при составлении плана тестирования.


	20. Что такое пирамида / уровни тестирования?

«Пирамида тестов» — абстракция, которая означает группировку тестов программного обеспечения по разным уровням детализации.

Она также даёт представление, сколько тестов должно быть в каждой из этих групп. 

Из этой пирамиды главное запомнить два принципа:
	Писать тесты разной детализации.
	Чем выше уровень, тем меньше тестов.

Придерживайтесь формы пирамиды, чтобы придумать здоровый, быстрый и поддерживаемый набор тестов.

-Напишите много маленьких и быстрых юнит-тестов.

-Напишите несколько более общих тестов

- и совсем мало высокоуровневых сквозных тестов, которые проверяют приложение от начала до конца.

Подробнее о Классической пирамиде тестирования:

Тестовая пирамида - визуализация, описывающая различные уровни тестирования и объем тестирования на каждом слое тестирования.

Модульные тесты должны составлять основную часть автоматизированного тестирования.
- Задачи автоматизации не закрываются до тех пор, пока эти скрипты не будут запущены на реализованной функциональности;
- Разработка одновременно с модульными тестами заставляет разработчиков задуматься о проблеме, которую они решают, и о любых крайних случаях, с которыми они могут столкнуться;
- Тесты являются детальными и могут помочь точно определить дефект;
- Время выполнения невероятно быстрое, потому что им не нужно полагаться на какой-либо пользовательский интерфейс или внешние системы, такие как база данных или API;
- Они недорогие, просто пишутся, легко поддерживать.

Интеграционные тесты должны занимать середину пирамиды.
Используйте этот уровень для проверки бизнес-логики без использования пользовательского интерфейса (UI);
Тестируя за пределами пользовательского интерфейса, вы можете тестировать входы и выходы API или сервисов без всех сложностей, которые вводит пользовательский интерфейс;
Эти тесты медленнее и сложнее, чем модульные тесты, потому что им может потребоваться доступ к базе данных или другим компонентам.

Тесты пользовательского интерфейса должны размещаться на вершине пирамиды.
Большая часть вашего кода и бизнес-логики должна быть уже протестирована до этого уровня;
Тесты интерфейса пишутся, чтобы убедиться, что сам интерфейс работает правильно;
Тесты пользовательского интерфейса медленнее и тяжелее в написании и поддержке, поэтому необходимо сводить их к минимуму.


	21. Что такое деструктивное/разрушающее/негативное тестирование? (DT — Destructive testing)

ОТРИЦАТЕЛЬНОЕ ТЕСТИРОВАНИЕ - тип тестирования ПО для поиска точек отказа в программном обеспечении, 
который проверяет систему на обработку исключительных ситуаций (срабатывание валидаторов на некорректные данные), 
а также проверяет, что вызываемая приложением функция не выполняется при срабатывании валидатора. 
Неожиданные условия могут быть чем угодно, от неправильного типа данных до хакерской атаки. 
Целью отрицательного тестирования является предотвращение сбоя приложений из-за некорректных входных данных. 
Просто проводя положительное тестирование, мы можем только убедиться, что наша система работает в нормальных условиях. 
Мы должны убедиться, что наша система может справиться с непредвиденными условиями, чтобы обеспечить 100% безошибочную систему. 
Типичные примеры: ввести неправильно составленный e-mail и номер телефона, загрузить файл не предусмотренного расширения или размера.  
Для деструктивного тестирования существует множество способов его тестирования: 
Метод анализа точек отказа: это пошаговое прохождение системы, проводящее оценку того, что может пойти не так в разных точках. 
Для этой стратегии может быть использована помощь BA (Business Analyst). 
Экспертная проверка тестировщика: проанализируйте или дайте на ревью ваши Test вашему коллеге-тестировщику, который менее знаком с системой/функцией 
Бизнес-анализ тестовых случаев. Конечные пользователи или эксперты могут подумать о многих допустимых сценариях, которые иногда тестировщики могут не учитывать или упустить, 
так как все их внимание будет сосредоточено на тестировании требований. 
Проведите предварительное тестирование с использованием контрольных таблиц (run sheets). 
Исследовательское тестирование с использованием контрольных таблиц поможет определить, что было проверено, повторить тесты и позволит вам контролировать охват тестами. 
Используйте другой источник: вы можете попросить кого-нибудь сломать программный продукт и проанализировать различные сценарии.


	22. Что такое недеструктивное/неразрушающее/позитивное тестирование? (NDT – Non Destructive testing)

НЕДЕСТРУКТИВНОЕ ТЕСТИРОВАНИЕ - это тип тестирования программного обеспечения, который включает в себя правильное взаимодействие с программным обеспечением. 
Другими словами, неразрушающее тестирование (NDT) также можно назвать позитивным тестированием или тестированием «счастливого пути». 
Это дает ожидаемые результаты и доказывает, что программное обеспечение ведет себя так, как ожидалось. 
	Пример: 
- Ввод правильных данных в модуль входа в систему и проверка, принимает ли он учетные данные и переходит на следующую страницу


	23. Что подразумевается под компонентным/модульным/юнит тестированием? (Component/Module/Unit testing)

	Модульные тесты используются для тестирования какого-либо одного логически выделенного и изолированного элемента системы в коде. 
Очевидно, что это тестирование методом белого ящика и чаще всего оно проводится самими разработчиками. 
Целью тестирования модуля является не демонстрация правильного функционирования модуля, 
а демонстрация наличия ошибки в модуле, а также в определении степени готовности системы к переходу на следующий уровень разработки и тестирования. 
На уровне модульного тестирования проще всего обнаружить дефекты, связанные с алгоритмическими ошибками и ошибками кодирования алгоритмов, 
типа работы с условиями и счетчиками циклов, а также с использованием локальных переменных и ресурсов. 
Ошибки, связанные с неверной трактовкой данных, некорректной реализацией интерфейсов, совместимостью, производительностью 
и т.п. обычно пропускаются на уровне модульного тестирования и выявляются на более поздних стадиях тестирования. 
Изоляция тестируемого блока достигается с помощью заглушек (stubs), манекенов (dummies) и макетов (mockups). 
Являясь по способу исполнения структурным тестированием или тестированием "белого ящика", модульное тестирование характеризуется степенью, 
в которой тесты выполняют или покрывают логику программы (исходный текст). Тесты, связанные со структурным тестированием, строятся по следующим принципам:
На основе анализа потока управления. В этом случае элементы, которые должны быть покрыты при прохождении тестов, определяются на основе структурных критериев тестирования С0, С1,С2. 
К ним относятся вершины, дуги, пути управляющего графа программы (УГП), условия, комбинации условий и т. п.
На основе анализа потока данных, когда элементы, которые должны быть покрыты, определяются при помощи потока данных, т. е. информационного графа программы.
Тестирование на основе потока управления. Особенности использования структурных критериев тестирования С0,С1,С2 были рассмотрены ранее. К ним следует добавить критерий покрытия условий, з
аключающийся в покрытии всех логических (булевских) условий в программе. Критерии покрытия решений (ветвей - С1) и условий не заменяют друг друга, поэтому на практике используется 
комбинированный критерий покрытия условий/решений, совмещающий требования по покрытию и решений, и условий. 
К популярным критериям относятся критерий покрытия функций программы, 
согласно которому каждая функция программы должна быть вызвана хотя бы один раз, и критерий покрытия вызовов, согласно которому каждый вызов каждой функции в программе должен быть осуществлен хотя бы один раз. 
Критерий покрытия вызовов известен также как критерий покрытия пар вызовов (call pair coverage). Тестирование на основе потока данных. 
Этот вид тестирования направлен на выявление ссылок на неинициализированные переменные и избыточные присваивания (аномалий потока данных ). 
Предложенная там стратегия требовала тестирования всех взаимосвязей, включающих в себя ссылку (использование) и определение переменной, на которую указывает ссылка 
(т. е. требуется покрытие дуг информационного графа программы). Недостаток стратегии в том, что она не включает критерий С1, и не гарантирует покрытия решений. 
Стратегия требуемых пар также тестирует упомянутые взаимосвязи. Использование переменной в предикате дублируется в соответствии с числом выходов решения, 
и каждая из таких требуемых взаимосвязей должна быть протестирована. К популярным критериям принадлежит критерий СР, заключающийся в покрытии всех таких пар дуг v и w, 
что из дуги v достижима дуга w, поскольку именно на дуге может произойти потеря значения переменной, которая в дальнейшем уже не должна использоваться. 
Для "покрытия" еще одного популярного критерия Cdu достаточно тестировать пары (вершина, дуга), поскольку определение переменной происходит в вершине УГП, 
а ее использование - на дугах, исходящих из решений, или в вычислительных вершинах. 
Методы проектирования тестовых путей для достижения заданной степени тестированности в структурном тестировании. 
Процесс построения набора тестов при структурном тестировании принято делить на три фазы:

Конструирование УГП.
Выбор тестовых путей.
Генерация тестов, соответствующих тестовым путям.

Первая фаза соответствует статическому анализу программы, задача которого состоит в получении графа программы и зависящего от него и от критерия тестирования множества элементов, которые необходимо покрыть тестами. 
На третьей фазе по известным путям тестирования осуществляется поиск подходящих тестов, реализующих прохождение этих путей.
Вторая фаза обеспечивает выбор тестовых путей. 

Выделяют три подхода к построению тестовых путей:

Статические методы.

Динамические методы.

Методы реализуемых путей.

	Статические методы. Самое простое и легко реализуемое решение - построение каждого пути посредством постепенного его удлинения за счет добавления дуг, пока не будет достигнута выходная вершина управляющего графа программы. 
Эта идея может быть усилена в так называемых адаптивных методах, которые каждый раз добавляют только один тестовый путь (входной тест), используя предыдущие пути (тесты) как руководство для выбора последующих путей в соответствии с некоторой стратегией. 
Чаще всего адаптивные стратегии применяются по отношению к критерию С1. 
Основной недостаток статических методов заключается в том, что не учитывается возможная нереализуемость построенных путей тестирования. 
Динамические методы. Такие методы предполагают построение полной системы тестов, удовлетворяющих заданному критерию, путем одновременного решения задачи построения покрывающего множества путей и тестовых данных. 
При этом можно автоматически учитывать реализуемость или нереализуемость ранее рассмотренных путей или их частей. 
Основной идеей динамических методов является подсоединение к начальным реализуемым отрезкам путей дальнейших их частей так, чтобы: 
1) не терять при этом реализуемости вновь полученных путей; 
2) покрыть требуемые элементы структуры программы. Методы реализуемых путей. Данная методика заключается в выделении из множества путей подмножества всех реализуемых путей. 
После чего покрывающее множество путей строится из полученного подмножества реализуемых путей. 
Достоинство статических методов состоит в сравнительно небольшом количестве необходимых ресурсов, как при использовании, так и при разработке. 
Однако их реализация может содержать непредсказуемый процент брака (нереализуемых путей). 
роме того, в этих системах переход от покрывающего множества путей к полной системе тестов пользователь должен осуществить вручную, а эта работа достаточно трудоемкая.

	Динамические методы требуют значительно больших ресурсов как при разработке, так и при эксплуатации, однако увеличение затрат происходит, 
в основном, за счет разработки и эксплуатации аппарата определения реализуемости пути (символический интерпретатор, решатель неравенств). 
Достоинство этих методов заключается в том, что их продукция имеет некоторый качественный уровень - реализуемость путей. 
Методы реализуемых путей дают самый лучший результат. Компонентное тестирование — тип тестирования ПО, 
при котором тестирование выполняется для каждого отдельного компонента отдельно, без интеграции с другими компонентами. 
Его также называют модульным тестированием (Module testing), если рассматривать его с точки зрения архитектуры. 
Как правило, любое программное обеспечение в целом состоит из нескольких компонентов. 
Тестирование на уровне компонентов (Component Level testing) имеет дело с тестированием этих компонентов индивидуально. 
Это один из самых частых типов тестирования черного ящика, который проводится командой QA. 
Для каждого из этих компонентов будет определен сценарий тестирования, который затем будет приведен к Test case высокого уровня -> детальным Test case низкого уровня с предварительными условиями. 
Исходя из глубины уровней тестирования, компонентное тестирование можно классифицировать как:
Тестирование компонентов в малом (CTIS — Component testing In Small). Тестирование компонентов может проводиться с или без изоляции остальных компонентов в тестируемом программном обеспечении или приложении. 
Если это выполняется с изоляцией другого компонента, то это называется CTIS. Пример: веб-сайт, на котором есть 5 разных веб-страниц, тестирование каждой веб-страницы отдельно и с изоляцией других компонентов.
Тестирование компонентов в целом (CTIL — Component testing In Large). Тестирование компонентов, выполненное без изоляции других компонентов в тестируемом программном обеспечении или приложении, называется CTIL. 
Давайте рассмотрим пример, чтобы понять это лучше. Предположим, что есть приложение, состоящее из трех компонентов, таких как Компонент A, Компонент B и Компонент C. Разработчик разработал компонент B и хочет его протестировать. 
Но для того, чтобы полностью протестировать компонент B, некоторые его функции зависят от компонента A, а некоторые — от компонента C. Функциональный поток: A -> B -> C, что означает, 
что существует зависимость от B как от A, так и от C, заглушка - вызываемая функция, а драйвер - вызывающая функция. Но компонент A и компонент C еще не разработаны. 
В этом случае, чтобы полностью протестировать компонент B, мы можем заменить компонент A и компонент C заглушкой и драйверами по мере необходимости. 
Таким образом, в основном, компоненты A & C заменяются заглушками и драйверами, которые действуют как фиктивные объекты до тех пор, пока они фактически не будут разработаны.


	24. Что подразумевается под интеграционным тестированием?

	Интеграционное тестирование предназначено для проверки насколько хорошо два или более модулей ПО взаимодействуют друг с другом, 
а также взаимодействия с различными частями системы (операционной системой, оборудованием либо связи между различными системами). 
С технологической точки зрения интеграционное тестирование является количественным развитием модульного, поскольку так же, как и модульное тестирование, 
оперирует интерфейсами модулей и подсистем и требует создания тестового окружения, включая заглушки ( Stub ) на месте отсутствующих модулей. 
Основная разница между модульным и интеграционным тестированием состоит в целях, то есть в типах обнаруживаемых дефектов, которые, в свою очередь, 
определяют стратегию выбора входных данных и методов анализа. 
В частности, на уровне интеграционного тестирования часто применяются методы, связанные с покрытием интерфейсов, 
например, вызовов функций или методов, или анализ использования интерфейсных объектов, таких как глобальные ресурсы, средства коммуникаций, предоставляемых операционной системой. 
	
	Уровни интеграционного тестирования:

Компонентный интеграционный уровень (Component Integration testing): 
Проверяется взаимодействие между компонентами системы после проведения компонентного тестирования.

Системный интеграционный уровень (System Integration testing): Проверяется взаимодействие между разными системами после проведения системного тестирования.
Подходы к интеграционному тестированию:
Подход Большого взрыва:
Инкрементальный подход:
Нисходящий подход
Подход снизу-вверх
Сэндвич-подход
Некоторые утверждают, что всех участников (например, вызываемые классы) тестируемого субъекта следует заменить на имитации (mocks) или заглушки (stubs), 
чтобы создать идеальную изоляцию, избежать побочных эффектов и сложной настройки теста. 
Другие утверждают, что на имитации и заглушки следует заменять только участников, которые замедляют тест или проявляют сильные побочные эффекты (например, классы с доступом к БД или сетевыми вызовами). 
Иногда эти два вида юнит-тестов называют одинокими (solitary) в случае тотального применения имитаций и заглушек или общительными (sociable) в случае реальных коммуникаций с другими участниками. 
Информация должна приходить в течение нескольких секунд или нескольких минут с быстрых тестов на ранних этапах конвейера. 
И наоборот, более длительные тесты — обычно с более широкой областью — размещаются на более поздних этапах, чтобы не тормозить фидбек от быстрых тестов. 
Как видите, этапы конвейера развертывания определяются не типами тестов, а их скоростью и областью действия. 
Поэтому очень разумно может быть разместить некоторые из самых узких и быстрых интеграционных тестов на ту же стадию, что и юнит-тесты — просто потому что они дают более быструю обратную связь


	25. Разница между Unit testing и Integration testing?

На практике получается так: если тест…
	использует базу данных,
	использует сеть для вызова другого компонента/приложения,
	использует внешнюю систему (например, очередь или почтовый сервер),
	читает/записывает файлы или выполняет другие операции ввода-вывода,
	полагается не на исходный код, а на бинарник приложения,
… то это интеграционный, а не модульный тест

	Итог: хотя теоретически можно использовать только интеграционные тесты, на практике
	Юнит-тесты легче поддерживать.
	Юнит-тесты легко воспроизводят пограничные случаи и редкие ситуации.
	Юнит-тесты выполняются гораздо быстрее интеграционных тестов.
	Сбойные юнит-тесты легче исправить, чем интеграционные.

Нужны как модульные, так и интеграционные тесты одновременно. Они не взаимоисключающие.


	26. Что такое системное интеграционное тестирование? (SIT — System Integration testing)

Это тип тестирования программного обеспечения, проводимого в интегрированной аппаратной и программной среде для проверки поведения всей системы. 
Это тестирование, проведенное на полной интегрированной системе для оценки соответствия системы ее установленным требованиям. 
SIT выполняется для проверки взаимодействия между модулями программной системы. Оно занимается проверкой требований к программному обеспечению высокого и низкого уровня, 
указанных в Software Requirements Specification/Data and the Software Design Document. 
Он также проверяет сосуществование программной системы с другими и тестирует интерфейс между модулями программного приложения. 
В этом типе тестирования модули сначала тестируются индивидуально, а затем объединяются в систему. 
Например, программные и / или аппаратные компоненты объединяются и тестируются постепенно, пока не будет интегрирована вся система.


	27. В чем разница между тест-драйвером и тест-заглушкой? (Test Driver and Test Stub)

	Тестовый драйвер - это фрагмент кода, который вызывает тестируемый программный компонент. 
	Это полезно при тестировании по принципу «снизу-вверх». 
	Тестовая заглушка - это фиктивная программа, которая интегрируется с приложением для полной функциональности. 
Они актуальны для тестирования, в котором используется нисходящий подход. Пример.  
1. Допустим, есть сценарий для проверки интерфейса между модулями A и B. 
Мы разработали только модуль-A. Затем мы можем проверить модуль-A, если у нас есть реальный модуль-B или фиктивный модуль для него. В этом случае мы называем модуль-B тестовой заглушкой.  
2. Теперь модуль B не может отправлять или получать данные напрямую из модуля A. В таком сценарии мы перемещаем данные из одного модуля в другой, используя некоторые внешние функции, называемые Test Driver. 
Заглушки и драйверы не реализуют всю логику программного модуля, а только моделируют обмен данными с вызывающим модулем. 
Заглушка: вызывается тестируемым модулем. 
Драйвер: вызывает модуль для тестирования.


	28. Системное тестирование качественно отличается от интеграционного и модульного уровней. 
Системное тестирование рассматривает тестируемую систему в целом и оперирует на уровне пользовательских интерфейсов, в отличие от последних фаз интеграционного тестирования, которое оперирует на уровне интерфейсов модулей. 
Различны и цели этих уровней тестирования. На уровне системы часто сложно и малоэффективно анализировать прохождение тестовых траекторий внутри программы или отслеживать правильность работы конкретных функций. 
Основная задача системного тестирования - в выявлении дефектов, связанных с работой системы в целом, таких как неверное использование ресурсов системы, 
непредусмотренные комбинации данных пользовательского уровня, несовместимость с окружением, непредусмотренные сценарии использования, отсутствующая или неверная функциональность, неудобство в применении и тому подобное. 
Системное тестирование производится над проектом в целом с помощью метода "черного ящика". Структура программы не имеет никакого значения, для проверки доступны только входы и выходы, видимые пользователю. 
Категории тестов системного тестирования:
Полнота решения функциональных задач.
Стрессовое тестирование - на предельных объемах нагрузки входного потока.
Корректность использования ресурсов (утечка памяти, возврат ресурсов).
Оценка производительности.
Эффективность защиты от искажения данных и некорректных действий.
Проверка инсталляции и конфигурации на разных платформах.
Корректность документации
Для минимизации рисков, связанных с особенностями поведения системы в той или иной среде, во время тестирования рекомендуется использовать окружение максимально приближенное к тому, на которое будет установлен продукт после выдачи. 
Системное тестирование относят к черному ящику. Можно выделить два подхода к системному тестированию:
на базе требований (requirements based): Для каждого требования пишутся Test case, проверяющие выполнение данного требования.
на базе случаев использования (use case based): На основе представления о способах использования продукта создаются случаи использования системы (Use Cases). 
По конкретному случаю использования можно определить один или более сценариев. На проверку каждого сценария пишутся Test case, которые должны быть протестированы.


	29. Что такое функциональное тестирование?

Функциональное тестирование рассматривает заранее указанное поведение и основывается на анализе спецификаций функциональности компонента или системы в целом. 
Функциональные тесты основываются на функциях, выполняемых системой, и могут проводиться на всех уровнях тестирования (компонентном, интеграционном, системном, приемочном). 
Как правило, эти функции описываются в требованиях, функциональных спецификациях или в виде случаев использования системы (use cases). 
Тестирование в перспективе «требования» использует спецификацию функциональных требований к системе как основу для дизайна Test case. 
В этом случае необходимо сделать список того, что будет тестироваться, а что нет, приоритезировать требования на основе рисков (если это не сделано в документе с требованиями), 
а на основе этого приоритезировать тестовые сценарии. 
Это позволит сфокусироваться и не упустить при тестировании наиболее важный функционал. 
Тестирование в перспективе «бизнес-процессы» использует знание этих самых бизнес-процессов, которые описывают сценарии ежедневного использования системы. 
В этой перспективе тестовые сценарии (test scripts), как правило, основываются на случаях использования системы (use cases). 

Преимущества функционального тестирования:
имитирует фактическое использование системы;

Недостатки функционального тестирования:
возможность упущения логических ошибок в программном обеспечении;
вероятность избыточного тестирования.

	30. Что такое тестирование совместимости/взаимодействия? (Compatibility/Interoperability testing)

Тестирование взаимодействия - функциональное тестирование, проверяющее способность приложения/устройства взаимодействовать с одним 
и более компонентами/системами/устройствами и включающее в себя тестирование совместимости (compatibility testing) и интеграционное тестирование (integration testing).  
ПО с хорошими характеристиками взаимодействия может быть легко интегрировано с другими системами, не требуя каких-либо серьезных модификаций. 
В этом случае, количество изменений и время, требуемое на их выполнение, могут быть использованы для измерения возможности взаимодействия. 
Например, тестирование совместимости проводится между смартфонами и планшетами для проверки передачи данных через Bluetooth. 

Существуют разные уровни тестирования совместимости:

Аппаратное обеспечение: проверяет совместимость программного обеспечения с различными аппаратными конфигурациями. 

Операционные системы: Он проверяет ваше программное обеспечение на совместимость с различными операционными системами, такими как Windows, Unix*, Mac OS и т. д. 

Программное обеспечение: проверяет ваше разработанное программное обеспечение на совместимость с другим программным обеспечением. 
Например, приложение MS Word должно быть совместимо с другими программами, такими как MS Outlook, MS Excel, VBA и т. д. 

Сеть: оценка производительности системы в сети с различными параметрами, такими как пропускная способность, скорость работы, емкость. 

Браузер: проверяет совместимость вашего сайта с различными браузерами, такими как Firefox, Google Chrome, Internet Explorer и т. д. 

Устройства: проверяет совместимость вашего программного обеспечения с различными устройствами, такими как устройства USB-порта, 
принтеры и сканеры, другие мультимедийные устройства и Bluetooth. 

Mobile: проверка совместимости вашего программного обеспечения с мобильными платформами, такими как Android, iOS и т. д. 

Версии программного обеспечения. Он проверяет совместимость вашего программного приложения с различными версиями программного обеспечения. 
Например, проверка Microsoft Word на совместимость с Windows 7, Windows 7 SP1, Windows 7 SP2, Windows 7 SP3.

	Существует два типа проверки версий:

	*Тестирование обратной совместимости предназначено для проверки поведения разработанного аппаратного / программного обеспечения с использованием более старых версий аппаратного / программного обеспечения. 

	*Тестирование прямой совместимости заключается в проверке поведения разработанного аппаратного / программного обеспечения с использованием более новых версий аппаратного / программного обеспечения.

	
	31. Что такое тестирование на соответствие? (Conformance/Compilance testing)

	CONFORMANCE testing - это тип тестирования программного обеспечения, который удостоверяет, что система программного обеспечения соответствует стандартам и правилам, 
определенным IEEE, W3C или ETSI. 

	Цель проверки соответствия состоит в том, чтобы определить, в какой степени отдельная реализация конкретного стандарта соответствует индивидуальным требованиям этого стандарта. 

	Включает в себя:

Производительность
Функции 
Прочность (Robustness)
Совместимость (Interoperability) 
Поведение системы
Тестирование соответствия может быть логическим или физическим, и оно включает в себя следующие типы тестирования: 
Тестирование на соответствие (Compliance testing)
Нагрузочное тестирование (Load testing)
Стресс тестирование (Stress testing)
Объемное тестирование (Volume testing)



	32. Что такое нефункциональное тестирование?

НЕФУНКЦИОНАЛЬНОЕ тестирование определяется как тип тестирования ПО для проверки нефункциональных аспектов ПО. Оно предназначено для проверки готовности системы по нефункциональным параметрам, которые никогда не учитываются при функциональном тестировании.
Нефункциональное тестирование должно повысить удобство использования, эффективность, ремонтопригодность и portability продукта. 
Помогает снизить производственный риск и затраты, связанные с нефункциональными аспектами продукта. 

Позволяет:
оптимизировать способ установки, настройки, выполнения, управления и мониторинга продукта. 
Собирать и производить измерения и метрики для внутренних исследований и разработок. 
Улучшать и расширять знания о поведении продукта и используемых технологиях.

Основные нефункциональные типы тестирования:

Производительности (Performance)
Стрессовое (Stress testing)
Тестирование емкости/способностей (Capacity testing)
Нагрузочное (Load testing)
Объемное тестирование (Volume testing)
Выносливости/стабильности/надежности (Soak/Endurance/Stability/Reliability testing)
Шиповое (Spike)
Масштабируемости (Scalability Test)
Тестирование времени отклика (Response Time testing)
Тестирование на отказоустойчивость (Failover testing)
Тестирование совместимости (Compatibility testing)
Тестирование на удобство пользования (Usability testing)
Тестирование на поддерживаемость/ремонтопригодность (Maintainability testing)
Тестирование безопасности (Security testing)
Тестирование аварийного восстановления (Disaster Recovery testing)
Тестирование на соответствие (Compliance testing)
Тестирование переносимости (Portability testing)
Тестирование эффективности (Efficiency testing)
Базовое тестирование (Baseline testing)
Тестирование документации (Documentation testing)
Тестирование восстановления (Recovery testing)
Интернационализация (Globalization/Internationalization testing)
Тестирование локализации (Localization testing)


	33. Что вы знаете о Тестировании удобства пользования?(Usability testing)

	Тестирование удобства пользования - это метод тестирования, направленный на установление степени удобства использования, обучаемости, 
понятности и привлекательности для пользователей разрабатываемого продукта в контексте заданных условий. 
Тестирование удобства пользования дает оценку уровня удобства использования приложения по следующим пунктам:
производительность, эффективность (efficiency) - сколько времени и шагов понадобится пользователю для завершения основных задач приложения, например, размещение новости, регистрации, покупка и т. д. ? (меньше - лучше)
правильность (accuracy) - сколько ошибок сделал пользователь во время работы с приложением? (меньше - лучше)
активизация в памяти (recall) – как много пользователь помнит о работе приложения после приостановки работы с ним на длительный период времени? (повторное выполнение операций после перерыва должно проходить быстрее чем у нового пользователя)
эмоциональная реакция (emotional response) – как пользователь себя чувствует после завершения задачи - растерян, испытал стресс? Порекомендует ли пользователь систему своим друзьям? (положительная реакция - лучше)
Проверка удобства использования может проводиться как по отношению к готовому продукту, посредством тестирования черного ящика (black box testing), так и к интерфейсам приложения (API), 
используемым при разработке - тестирование белого ящика (white box testing). В этом случае проверяется удобство использования внутренних объектов, классов, методов и переменных, 
а также рассматривается удобство изменения, расширения системы и интеграции ее с другими модулями или системами. 
Использование удобных интерфейсов (API) может улучшить качество, увеличить скорость написания и поддержки разрабатываемого кода, и как следствие улучшить качество продукта в целом. 
Отсюда становится очевидно, что тестирование удобства пользования может производиться на разных уровнях разработки ПО: модульном, интеграционном, системном и приемочном.


	34. Отличия тестирование на удобство пользования и тестирования доступности? (Usability Vs. Accessibility testing)

USABILITY testing показывает, насколько проста в использовании и удобна система программного обеспечения. 
Здесь небольшой набор целевых конечных пользователей «использует» программную систему для выявления дефектов юзабилити. 
Основное внимание в этом тестировании уделяется простоте использования приложения пользователем, гибкости в управлении средствами управления и способности системы выполнять свои задачи. 
Это также называется тестированием пользовательского опыта (UX – "Ю-Экс", user experience). Это тестирование рекомендуется на начальном этапе разработки SDLC, что позволяет лучше понять ожидания пользователей. 
Исследования (Virzi, 1992 и Neilsen Landauer, 1993) показывают, что 5 пользователей достаточно для выявления 80% проблем с юзабилити, хотя некоторые исследователи предлагают другие цифры. 
естирование доступности (accessibility testing) - это подмножество юзабилити-тестирования. Его цель - убедиться в том, что наш продукт удобен в использовании для людей с различными видами инвалидности или особенностей восприятия. 
Это могут быть проблемы со зрением, слухом или ограничения в подвижности рук.  Ваш продукт должен правильно работать с соответствующим ПО. 

Примеры такого программного обеспечения:

Speech Recognition Software - ПО преобразует произнесенное слово в текст, который служит вводом для компьютера. 
Программа для чтения с экрана - используется для озвучивания текста, отображаемого на экране 
Программное обеспечение для увеличения экрана - используется для увеличения масштаба элементов и облегчения чтения для пользователей с нарушениями зрения. 
Специальная клавиатура, облегчающая ввод для пользователей, у которых проблемы с двигательными функциями.
Еще один из примеров - люди с цветовой слепотой (дальтонизмом). Эта особенность довольно широко распространена. 
Различными видами цветовой слепоты страдают около 8 % мужчин и 0,4 % женщин - не так уж мало! Цвет не должен быть единственным способом передачи информации. 
Если вы используете цвет для того, чтобы, допустим, отобразить статус, эту информацию стоит продублировать еще каким-то образом - геометрическими фигурами, иконками или текстовым комментарием. 
Хорошая контрастность. Хорошая контрастность обеспечивает нормальную видимость элементов управления и текста даже для людей, не различающих те или иные оттенки. 
Есть отличный инструмент для тестирования веб-сайтов на предмет доступности для людей с различными формами цветовой слепоты: Color Blind Web Page Filter.  

Если вы хотите сократить количество тестов, можно ограничиться только тремя фильтрами: дейтеранопия, протанопия и тританопия. 
Это наиболее выраженные формы цветовой слепоты (не считая крайне редкого черно-белого зрения). 
Остальные люди с особенностями цветовосприятия видят больше оттенков, и если ваш UI достаточно хорошо виден с этими тремя фильтрами, то и для остальных будет отображаться корректно. 
Пример чек-листа:
Предоставляет ли приложение клавиатурные эквиваленты для всех действий мышью и окон? 
Предоставляются ли инструкции как часть пользовательской документации или руководства? Легко ли понять и использовать приложение, используя документацию? 
Упорядочены ли вкладки логически для обеспечения плавной навигации? 
Предусмотрены ли сочетания клавиш для меню? 
Поддерживает ли приложение все операционные системы? 
Четко ли указано время отклика каждого экрана или страницы, чтобы конечные пользователи знали, как долго ждать? 
Все ли надписи правильно написаны? 
Являются ли цвета подходящим для всех пользователей? 
Правильно ли используются изображения или значки, чтобы их было легко понять конечным пользователям? 
Есть ли звуковые оповещения? 
Может ли пользователь настроить аудио или видео элементы управления? 
Может ли пользователь переопределить шрифты по умолчанию для печати и отображения текста? 
Может ли пользователь настроить или отключить мигание, вращение или перемещение элементов? 
Убедитесь, что цветовое кодирование никогда не используется в качестве единственного средства передачи информации или указания на действие 
Видна ли подсветка с инвертированными цветами? 
Тестирование цвета в приложении путем изменения контрастности 
Правильно ли слышат люди с ограниченными возможностями все имеющее отношение к аудио и видео?
Протестируйте все мультимедийные страницы без мультимедиа-оборудования. 
Предоставляется ли обучение пользователям с ограниченными возможностями, что позволит им ознакомиться с программным обеспечением или приложением?


	35. Что такое тестирование интерфейса?

Это тип интеграционного теста, который проверяет, правильно ли установлена ​​связь между двумя различными программными системами или их частями (модулями). 
Соединение, которое объединяет два компонента, называется интерфейсом. Этот интерфейс в компьютерном мире может быть чем угодно, как API, так и веб-сервисами и т. д.  

Тестирование этих подключаемых сервисов или интерфейса называется Тестированием интерфейса. Тестирование интерфейса включает в себя тестирование двух основных сегментов: 

	Интерфейс веб-сервера и сервера приложений 

	Интерфейс сервера приложений и базы данных




