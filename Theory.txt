	
	1. Что подразумевается под тестовой средой?

Тестовая среда (среда тестирования) — это комбинация аппаратной и программной среды, в которой будут выполняться тесты. Среда поддерживает выполнение теста с настроенным оборудованием, программным обеспечением и сетью.

Тестовая среда (испытательный стенд) настраивается в соответствии с требованиями тестируемого приложения. В некоторых случаях испытательный стенд может представлять собой комбинацию тестовой среды и тестовых данных, которые он использует.

Настройка правильной среды тестирования гарантирует успех тестирования программного обеспечения.

В тестовой среде работают тестировщики. Здесь тестировщики тестируют новые билды, проверяют функционал, проводят регрессионные проверки, воспроизводят ошибки. 

Эта среда появляется во время начала динамического тестирования.

	
	2. В чем отличие build от release?

Билд это номер, даваемый ПО при передаче от разработчиков тестировщикам. Релиз — это номер, даваемый ПО при передаче конечному пользователю.

	
	3. Основные фазы тестирования.

	Основными фазами тестирования являются:

	– модульное тестирование;
	– интеграционное тестирование;
	– системное тестирование (в том числе адаптационное, функциональное и нагрузочное);
	– регрессионное тестирование;
	– приемочное тестирование.

	На стадии модульного тестирования достаточно просто выявляются просчеты в логике построения модуля и/или реализации алгоритмов, ошибки, связанные с неправильным использованием локальных ресурсов, а также ошибки в локальных переменных.

	Следующим этапом явлется интеграционное тестирование. Оно проходит в несколько стадий и заключается в тестировании частей системы, состоящих из двух и большего количества модулей. 

	Третьим этапом является системное тестирование, которое существенным образом отличается от модульного и интеграционного. Оно рассматривает систему как черный ящик и работает исключительно с пользовательскими интерфейсами. 

Основной целью системного тестирования является проверка стабильности и корректности работы системы, а также соответствия функциональностей системы спецификациям, указанным в сопроводительных документах, 

проверяется работа системы на базе различных операционных систем и аппаратного обеспечения. Исследуется производительность тестируемого программного обеспечения.

	Основной целью регрессионного тестирования является проверка того, что в результате внесения изменений в программный код зафиксированные ранее ошибки исправлены, а новые не появляются. 

Для регрессионного тестирования используется специально разработанный набор тестов, из которого каждый раз выбираются те тесты, которые позволяют обнаружить появление новых ошибок с наибольшей вероятностью.

	Приемочное тестирование — тестирование интегральной функциональности системы на соответствие требованиям заказчика. Планируется с участием представителей заказчика. 

Проводится на заключительном этапе с целью удостовериться в том, что система работает так, как и ожидалось, все необходимые формы, процедуры присутствуют и функционируют нормально. 

Данное тестирование является высокоуровневой проверкой отсутствия пробелов в функциональности системы.

Положительные результаты бизнес-тестирования означают, что все компоненты системы работоспособны и включены в данную версию продукта.


	4. Что такое импакт анализ?

Impact Analysis (импакт анализ) - это исследование, которое позволяет указать затронутые места (affected areas) в проекте при разработке новой или изменении старой функциональности, а также определить, насколько значительно они были затронуты. 

Затронутые области требуют большего внимания во время проведения регрессионного тестирования. Импакт анализ может быть полезным в следующих случаях:

 * есть изменения в требованиях;

 * получен запрос на внесение изменений в продукт;

 * ожидается внедрение нового модуля или функциональности в существующий продукт;

 * каждый раз, когда есть изменения в существующих модулях или функциональностях продукта.

	В настоящее время продукты становятся все более большими и комплексными, а компоненты все чаще зависят друг от друга. 

Изменение строчки кода в таком проекте может "сломать" абсолютно все. Информация о взаимосвязи и взаимном влиянии изменений могут помочь QA:

сфокусироваться на тестировании функциональности, где изменения были представлены;

принять во внимание части проекта, которые были затронуты изменениями и, возможно, пострадали;

не тратить время на тестирование тех частей проекта, которые не были затронуты изменениями.

	5. Критерии выбора тестов.

Требования к идеальному критерию тестирования:

Критерий должен быть достаточным, т.е. показывать, когда некоторое конечное множество тестов достаточно для тестирования данной программы.
Критерий должен быть полным, т.е. в случае ошибки должен существовать тест из множества тестов, удовлетворяющих критерию, который раскрывает ошибку.
Критерий должен быть надежным, т.е. любые два множества тестов, удовлетворяющих ему, одновременно должны раскрывать или не раскрывать ошибки программы.
Критерий должен быть легко проверяемым, например вычисляемым на тестах.
Для нетривиальных классов программ в общем случае не существует полного и надежного критерия, зависящего от программ или спецификаций. 
Поэтому мы стремимся к идеальному общему критерию через реальные частные. 
	
Классы критериев:

Структурные критерии используют информацию о структуре программы (критерии так называемого "белого ящика").
Функциональные критерии формулируются в описании требований к программному изделию ( критерии так называемого "черного ящика" ).
Критерии стохастического тестирования формулируются в терминах проверки наличия заданных свойств у тестируемого приложения, средствами проверки некоторой статистической гипотезы.
Мутационные критерии ориентированы на проверку свойств программного изделия на основе подхода Монте-Карло.

	Структурные критерии используют модель программы в виде "белого ящика", что предполагает знание исходного текста программы или спецификации программы в виде потокового графа управления. 
Структурная информация понятна и доступна разработчикам подсистем и модулей приложения, поэтому данный класс критериев часто используется на этапах модульного и интеграционного тестирования (Unit testing, Integration testing). 
Структурные критерии базируются на основных элементах УГП (Управляющий граф программы), операторах, ветвях и путях.
Условие критерия тестирования команд (критерий С0) - набор тестов в совокупности должен обеспечить прохождение каждой команды не менее одного раза. 
Это слабый критерий, он, как правило, используется в больших программных системах, где другие критерии применить невозможно.
Условие критерия тестирования ветвей (критерий С1) - набор тестов в совокупности должен обеспечить прохождение каждой ветви не менее одного раза. 
Это достаточно сильный и при этом экономичный критерий, поскольку множество ветвей в тестируемом приложении конечно и не так уж велико. 
Данный критерий часто используется в системах автоматизации тестирования.
Условие критерия тестирования путей (критерий С2) - набор тестов в совокупности должен обеспечить прохождение каждого пути не менее 1 раза. 
сли программа содержит цикл (в особенности с неявно заданным числом итераций), то число итераций ограничивается константой (часто - 2, или числом классов выходных путей).
Структурные критерии не проверяют соответствие спецификации, если оно не отражено в структуре программы. 
Поэтому при успешном тестировании программы по критерию C2 мы можем не заметить ошибку, связанную с невыполнением некоторых условий спецификации требований. 
Функциональный критерий - важнейший для программной индустрии критерий тестирования. Он обеспечивает, прежде всего, контроль степени выполнения требований заказчика в программном продукте. 
Поскольку требования формулируются к продукту в целом, они отражают взаимодействие тестируемого приложения с окружением. 
При функциональном тестировании преимущественно используется модель "черного ящика". 
Проблема функционального тестирования - это, прежде всего, трудоемкость; дело в том, что документы, фиксирующие требования к программному изделию (Software requirement specification, Functional specification и т.п.), 
как правило, достаточно объемны, тем не менее, соответствующая проверка должна быть всеобъемлющей. 
Ниже приведены частные виды функциональных критериев:
	Тестирование пунктов спецификации - набор тестов в совокупности должен обеспечить проверку каждого тестируемого пункта не менее одного раза. 
Спецификация требований может содержать сотни и тысячи пунктов требований к программному продукту и каждое из этих требований при тестировании должно быть проверено в соответствии с критерием не менее чем одним тестом.
	Тестирование классов входных данных - набор тестов в совокупности должен обеспечить проверку представителя каждого класса входных данных не менее одного раза. 
При создании тестов классы входных данных сопоставляются с режимами использования тестируемого компонента или подсистемы приложения, что заметно сокращает варианты перебора, учитываемые при разработке тестовых наборов. 
Следует заметить, что перебирая в соответствии с критерием величины входных переменных (например, различные файлы - источники входных данных), мы вынуждены применять мощные тестовые наборы. 
Действительно, наряду с ограничениями на величины входных данных, существуют ограничения на величины входных данных во всевозможных комбинациях, в том числе проверка реакций системы на появление ошибок в значениях или структурах входных данных. 
Учет этого многообразия - процесс трудоемкий, что создает сложности для применения критерия.
	Тестирование правил - набор тестов в совокупности должен обеспечить проверку каждого правила, если входные и выходные значения описываются набором правил некоторой грамматики. 
Следует заметить, что грамматика должна быть достаточно простой, чтобы трудоемкость разработки соответствующего набора тестов была реальной (вписывалась в сроки и штат специалистов, выделенных для реализации фазы тестирования).
	Тестирование классов выходных данных - набор тестов в совокупности должен обеспечить проверку представителя каждого выходного класса, при условии, 
что выходные результаты заранее расклассифицированы, причем отдельные классы результатов учитывают, в том числе, ограничения на ресурсы или на время (time out). 
При создании тестов классы выходных данных сопоставляются с режимами использования тестируемого компонента или подсистемы, что заметно сокращает варианты перебора, учитываемые при разработке тестовых наборов.
	Тестирование функций - набор тестов в совокупности должен обеспечить проверку каждого действия, реализуемого тестируемым модулем, не менее одного раза. 
Очень популярный на практике критерий, который, однако, не обеспечивает покрытия части функциональности тестируемого компонента, связанной со структурными и поведенческими свойствами, 
описание которых не сосредоточено в отдельных функциях (т.е. описание рассредоточено по компоненту). Критерий тестирования функций объединяет отчасти особенности структурных и функциональных критериев. 
Он базируется на модели "полупрозрачного ящика", где явно указаны не только входы и выходы тестируемого компонента, но также состав и структура используемых методов (функций, процедур) и классов.
	
	Комбинированные критерии для программ и спецификаций - набор тестов в совокупности должен обеспечить проверку всех комбинаций непротиворечивых условий программ и спецификаций не менее одного раза. 
При этом все комбинации непротиворечивых условий надо подтвердить, а условия противоречий следует обнаружить и ликвидировать.
	
	Стохастическое тестирование применяется при тестировании сложных программных комплексов - когда набор детерминированных тестов (X,Y) имеет громадную мощность. 

	Мутационный критерий (класс IV). Постулируется, что профессиональные программисты пишут сразу почти правильные программы, 
отличающиеся от правильных мелкими ошибками или описками типа - перестановка местами максимальных значений индексов в описании массивов, 
ошибки в знаках арифметических операций, занижение или завышение границы цикла на 1 и т.п. Предлагается подход, позволяющий на основе мелких ошибок оценить общее число ошибок, оставшихся в программе. 
Подход базируется на следующих понятиях: Мутации - мелкие ошибки в программе. Мутанты - программы, отличающиеся друг от друга мутациями . 
Метод мутационного тестирования - в разрабатываемую программу P вносят мутации, т.е. искусственно создают программы-мутанты P1, P2... 
Затем программа P и ее мутанты тестируются на одном и том же наборе тестов (X,Y). Если на наборе (X,Y) подтверждается правильность программы P и, кроме того, выявляются все внесенные в программы-мутанты ошибки, 
то набор тестов (X,Y) соответствует мутационному критерию, а тестируемая программа объявляется правильной. Если некоторые мутанты не выявили всех мутаций, то надо расширять набор тестов (X,Y) и продолжать тестирование.

	
	6. Принципы тестирования

	1. Тестирование показывает наличие дефектов

Тестирование может показать наличие дефектов в программе, но не доказать их отсутствие. Тем не менее, важно составлять тест-кейсы, которые будут находить как можно больше багов. 
Таким образом, при должном тестовом покрытии, тестирование позволяет снизить вероятность наличия дефектов в программном обеспечении. 
В то же время, даже если дефекты не были найдены в процессе тестирования, нельзя утверждать, что их нет.

	2. Исчерпывающее тестирование невозможно

Невозможно провести исчерпывающее тестирование, которое бы покрывало все комбинации пользовательского ввода и состояний системы, за исключениям совсем уж примитивных случаев. 
sВместо этого необходимо использовать анализ рисков и расстановку приоритетов, что позволит более эффективно распределять усилия по обеспечению качества ПО.

	3. Раннее тестирование

Тестирование должно начинаться как можно раньше в жизненном цикле разработки программного обеспечения, и его усилия  должны быть сконцентрированы на определенных целях.

	4. Скопление дефектов

Разные модули системы могут содержать разное количество дефектов – то есть, плотность скопления дефектов в разных элементах программы может отличаться. 
Усилия по тестированию должны распределяться пропорционально фактической плотности дефектов. В основном, большую часть критических дефектов находят в ограниченном количестве модулей. 
Это проявление принципа Парето: 80% проблем содержатся в 20% модулей.

	5. Парадокс пестицида

Прогоняя одни и те же тесты вновь и вновь, тестировщики сталкиваются с тем, что они находят все меньше новых ошибок. Поскольку система эволюционирует, многие из ранее найденных дефектов исправляют и старые тест-кейсы больше не срабатывают.

Чтобы преодолеть этот парадокс, необходимо периодически вносить изменения в используемые наборы тестов, рецензировать и корректировать их с тем, чтобы они отвечали новому состоянию системы и позволяли находить как можно большее количество дефектов.

	6. Тестирование зависит от контекста

Выбор методологии, техники и типа тестирования будет напрямую зависеть от природы самой программы. Например, программное обеспечение для медицинских нужд требует гораздо более строгой и тщательной проверки, чем, скажем, компьютерная игра. 
Из тех же соображений, сайт с большой посещаемостью должен пройти через серьезное тестирование производительности, чтобы показать возможность работы в условиях высокой нагрузки.

	7. Заблуждение об отсутствии ошибок.

Тот факт, что тестирование не обнаружило дефектов, еще не значит, что программа готова к релизу. Нахождение и исправление дефектов будут не важны, если система окажется неудобной в использовании, и не будет удовлетворять ожиданиям и потребностям пользователя.
	
	
	7. Что такое независимое тестирование?

	Независимое тестирование соответствует независимой команде, которая участвует в тестировании, отличном от разработчика, чтобы избежать предвзятости автора и часто более эффективна в поиске дефектов и сбоев.	

	Иногда следует нанять независимую организацию по тестированию, которая тщательно проверит продукт на наличие сбоев, готовя его к развертыванию.  
	
	Тестирование по уровням независимости:

Программист тестирует свой код 
Тестирование проводится другим программистом в организации
Внутренняя команда тестирования 
Независимая организация тестирования

Когда программист проверяет свой код.

Тестирование проводится другим программистом в организации: компромисс - это найти кого-то в организации. Это может быть какой-то другой программист, который участвует в некоторых других проектах. 
Это дает определенный уровень независимости. Но проблема возникает из-за того же manager. Менеджер может попросить программиста пропустить некоторые тесты, когда есть ограничения по времени. 
Это приведет к неполному тестированию продукта. Кроме того, если попросить других разработчиков провести тестирование, это приведет к развертыванию различных ресурсов в одном проекте. Это будет вредно для всей работы организации. 

Внутренняя команда тестирования: Наличие другой внутренней команды - это хорошее решение. Но поскольку они будут в организации, на них будут влиять ограничительные сроки. 
Кроме того, это будет дорого поддерживать внутреннюю команду. Это приведет к большим бюджетным и ресурсным ограничениям для команды. 
Команда может иметь доступ к ограниченным инструментам и программному обеспечению, таким образом, не отвечая требованиям всех проектов. 
Среда тестирования также будет варьироваться в зависимости от количества пользователей и числа выполненных интеграций. 
Затем тестирование будет проводиться в спешном порядке, что приведет к упущению некоторых ошибок, которые могут появиться после выпуска продукта. 
Решение, которое позаботится обо всех этих недостатках, - «Независимое тестирование». 
Почему независимое тестирование? Независимые тестирующие организации изучат все аспекты продукции. 
Они работают с мышлением поиска недостатков и ошибок. Они не будут использовать ярлыки в процессе тестирования. 
И поскольку они не были частью процесса разработки, они будут проводить тесты на нейтральной основе, чтобы прежние интересы не мешали процессу тестирования. 
Мысль о поиске максимальных «точек останова» пойдет на пользу вашему продукту. Почти все сторонние тестирующие организации предоставят вам подробные отчеты об ошибках и предложат корректирующие меры. 


	8. Что такое тестирование со сдвигом влево?

	В попытке перенести тестирование на более ранний этап жизненного цикла разработки при одновременном улучшении показателей качества, задачи смещаются влево в схеме жизненного цикла разработки ПО. 
По возможности, тестирование должно проводиться с самого начала фазы проектирования, чтобы построить соответствующую стратегию тестирования. 
Проще говоря, это подход к тестированию программного обеспечения и тестированию системы, при котором тестирование выполняется на более раннем этапе жизненного цикла. 

Ключевые преимущества:
	* Сокращение затрат 
 	* Более высокое качество
 	* Повышение эффективности 
 	* Конкурентные преимущества


	9. Почему тестирование делится на отдельные этапы?

	* Каждый этап испытаний имеет свое назначение 
	* Проще управлять поэтапно 
	* Мы можем запустить разные тесты в разных средах 
	* Производительность и качество тестирования улучшаются с помощью поэтапного тестирования


	10. Этапы тестирования.

	 Всего принято выделять 7 этапов тестирования:

1 Работа с требованиями. Знакомство с требованиями заказчика, что должен из себя представлять итоговый продукт, обсуждение.
2 Разработка стратегии тестирования. Оценка сроков тестирования, выявление среды тестирования, объединение всей информации, полученной при работе с требованиями.
3 Создание тестовой документации. Написание сценариев, которые позволят проверить функционал.
4 Тестирование прототипа. Тестирование основного функционала продукта, корректировка целей, добавление фичей.
5 Основное тестирование. Выполнение общей проверки продукта.
6 Стабилизация. На данном этапе происходит работа над устранением багов.
7 Эксплуатация. Проводится регресс-тестирование, устранение ошибок, которые нашел конечный пользователь.
Прежде, чем переходить к описанию каждого цикла тестирования, необходимо запомнить важное правило: переход к следующему этапу допустим лишь после полного завершения работы на предыдущем.


	11. Как тестировать продукт, если нет требований.	 

	Использование неформальных техник тестирования:

	– Ad hoc тестирование

	– исследовательское (exploratory) тестирование.

Свободное тестирование (ad-hoc testing) – это вид тестирования, который выполняется без подготовки к тестированию продукта, без определения ожидаемых результатов, проектирования тестовых сценариев. 
Это неформальное, импровизационное тестирование. Оно не требует никакой документации, планирования, процессов, которых следует придерживаться при выполнении тестирования. 
Такой способ тестирования в большинстве случаев дает большее количество заведенных отчётов об ошибке.  Это обусловлено тем, что тестировщик на первых шагах приступает к тестированию основной функциональной 
части продукта и выполняет как позитивные, так и негативные варианты возможных сценариев.

Чаще всего такое тестирование выполняется, когда владелец продукта не обладает конкретными целями, проектной документацией и ранее поставленными задачами. 
При этом тестировщик полагается на свое общее представление о продукте, сравнение с похожими продуктами, собственный опыт. 
Однако при тестировании ad-hoc имеет смысл владеть общей информацией о продукте, особенно если проект очень сложный и большой. 
Поэтому нужно хорошее представление о целях проекта, его назначении и основных функциях и возможностях. А дальше уже можно приступать к ad-hoc тестированию.

Исследовательское тестирование (exploratory testing) — это одновременное изучение программного продукта, проектирование тестов и их выполнение. 
Это неформальный метод проектирования тестов, при котором тестировщик активно контролирует проектирование тестов в то время, как эти тесты выполняются, и использует полученную во время тестирования информацию для проектирования новых тестов.

Если каждый следующий тест, который выполняет тестировщик, выбирается по результатам предыдущего теста, это означает, что мы используем исследовательское тестирование.

Главное, что нужно помнить об исследовательском тестировании, это то, что само по себе оно не является методикой тестирования. 
Это, скорее, подход, который можно применить к любому виду тестирования. 
Еще один важный момент заключается в том, что исследовательское тестирование – это не только выполнение тестов. 
Тестировщики могут применять исследовательский подход и при разработке новых тестов в начале итерации, и при анализе уже завершенных тестов. 
Также, исследовательское тестирование не должно выполняться небрежно, в спешке и без подготовки. 
Исследовательский подход может требовать очень тщательной и длительной подготовки к определенным тестам, а накопленные за многие годы знания и умения тестировщика, применяющего данный подход, – это часто невидимая, но важная форма подготовки. 
Исследовательское тестирование может проводиться вручную, а может осуществляться с широким применением средств автоматизации, т.е. любых вспомогательных инструментов тестирования.

Когда следует применять исследовательское тестирование?

	Самые распространенные случаи:

когда нужно обеспечить быструю обратную связь для нового продукта или новой функциональности продукта;
когда нужно быстро ознакомиться с продуктом;
когда уже были проведены основные виды тестирования и время позволяет разнообразить методы тестирования;
когда нужно найти дефект, локализованный в определенном модуле в кратчайшие сроки;
когда проверяется работа другого специалиста по тестированию;
когда нужно изучить состояние конкретного риска для принятия решения о необходимости покрытия конкретной области  тестами.
Вывод

Описанные выше методы тестирования имеют основательные сходства и различия, поэтому стоит разделять эти две популярные методики в рамках  тестирования. 
Разница между ad-hoc и exploratory testing в том, что теоретически, ad-hoc может провести кто угодно, а для проведения exploratory необходимо мастерство и владение определёнными техниками. 
При этом, определённые техники – это не только техники тестирования.

Оба метода часто используются в проектах, а также являются неотъемлемой частью знаний и опыта современного  тестировщика программного обеспечения.

	12. Как узнать, было ли создано достаточно тестов для тестирования продукта?

Матрица прослеживаемости - это понятный инструмент, который обеспечивает соответствие требований тестовым примерам. 
Когда выполнение всех Test case заканчивается успешно, это указывает на то, что код соответствует требованиям. 

Матрица прослеживаемости - это документ, который связывает любые два базовых документа, которые требуют отношения «многие ко многим» для проверки полноты отношений. 
В случае тестирования это матрица покрытия функциональных требований тест-кейсами. 
Есть даже такое понятие как Requirement based testing, которое имеет место быть, когда есть требования к продукту, на их основе составляются тест-сценарии и выполняется тестирование. 
Зачем нужна эта матрица? 
Например, для того чтобы: - при разработке тестов четко ориентироваться какие из требований уже покрыты тестами, а какие еще нет; - при выполнении тестирования ориентироваться какие из требований прошли все написанные для них тесты успешно, а какие - еще нет. 
Матрица трассировки может служить одновременно в качестве матрицы покрытия. 
Наличие такой матрицы позволяет объективно оценить, какая часть продукта покрыта тестами, а какая нет. 
Это необходимое условие, чтобы оценить, какой объем работы мы уже выполнили и что еще осталось сделать - и по части создания, и по части выполнения тестов. 
Еще одно преимущество traceability matrix – ее наглядность. Если она поддерживается в актуальном состоянии, то можно сразу увидеть "белые пятна" и сосредоточиться на них. 
Traceability matrix также позволяет сравнивать тесты между собой по критерию количества требований, которые они покрывают. 
Одни тесты могут покрывать несколько требований, другие – только одно.


	13. Что подразумевается под тестовыми данными?

	Тестовые данные - это набор входных значений, необходимых для выполнения Test case. Тестировщики определяют данные в соответствии с требованиями. 
	
	Они могут сделать это вручную или использовать инструменты генерации.

	
	14. Что такое бета-тестирование?

	Бета-тестирование - интенсивное использование почти готовой версии продукта (как правило, программного или аппаратного обеспечения) с целью выявления максимального числа ошибок в его работе для их 

последующего устранения перед окончательным выходом продукта на рынок, к массовому потребителю.

	Бета-тестирование предполагает привлечение добровольцев из числа обычных будущих пользователей продукта, которым доступна предварительная версия продукта (так называемая бета-версия).

Такими добровольцами (их называют бета-тестерами) часто движет любопытство к новому продукту — любопытство, ради удовлетворения которого они вполне согласны мириться с возможностью испытать последствия ещё не найденных (а потому и не исправленных) ошибок. 

Кроме любопытства, мотивация может быть обусловлена желанием повлиять на процесс разработки и в итоге получать более удовлетворяющий их нужды продукт и многим другим.

Кроме того, открытие бета-тестирования может использоваться как часть стратегии продвижения продукта на рынок (например, бесплатная раздача бета-версий позволяет привлечь широкое внимание потребителей к окончательной дорогостоящей версии продукта), 

а также для получения предварительных отзывов о нём от широкого круга будущих пользователей.

Бета-версия не является финальной версией продукта, поэтому разработчик не гарантирует полного отсутствия ошибок, которые могут нарушить работу компьютера и/или привести к потере данных. 

Хотя и в финальных версиях таких гарантий разработчики, как правило, не дают.

Кроме программного и аппаратного обеспечения понятие бета-версия в последнее время часто применяется к сайтам, либо к их определённым разделам или функциям. 

При этом в большинстве случаев бета-тестирование является открытым, а доработки производятся в процессе функционирования сайта.


	15. Что означает пилотное тестирование? (Pilot)

	 PILOT testing определяется как тип тестирования программного обеспечения, который проверяет компонент системы или всю систему в режиме реального времени. 
Целью пилотного теста является оценка осуществимости, времени, стоимости, риска и эффективности исследовательского проекта. Это тестирование проводится точно между UAT и Production. 
В пилотном тестировании выбранная группа конечных пользователей пробует тестируемую систему и предоставляет обратную связь до полного развертывания системы. 
Другими словами, это означает проведение генеральной репетиции для последующего теста на удобство использования. Пилотное тестирование помогает в раннем обнаружении ошибок в Системе. 
Пилотное тестирование связано с установкой системы на площадке заказчика (или в среде, моделируемой пользователем) для тестирования на предмет постоянного и регулярного использования. 
Выявленные недостатки затем отправляются команде разработчиков в виде отчетов об ошибках, и эти ошибки исправляются в следующей сборке системы. 
Во время этого процесса иногда приемочное тестирование также включается как часть тестирования на совместимость. Это происходит, когда система разрабатывается для замены старой. 


	16. Чем AdHock тестирование отличается от исследовательского тестирования?

	Свободное тестирование (ad-hoc testing) – это вид тестирования, который выполняется без подготовки к тестированию продукта, без определения ожидаемых результатов, проектирования тестовых сценариев. 

Это неформальное, импровизационное тестирование. Оно не требует никакой документации, планирования, процессов, которых следует придерживаться при выполнении тестирования. 

Такой способ тестирования в большинстве случаев дает большее количество заведенных отчётов об ошибке.  

Это обусловлено тем, что тестировщик на первых шагах приступает к тестированию основной функциональной части продукта и выполняет как позитивные, так и негативные варианты возможных сценариев.

	Исследовательское тестирование (exploratory testing) — это одновременное изучение программного продукта, проектирование тестов и их выполнение. 

Это неформальный метод проектирования тестов, при котором тестировщик активно контролирует проектирование тестов в то время, как эти тесты выполняются, и использует полученную во время тестирования информацию для проектирования новых тестов.

Если каждый следующий тест, который выполняет тестировщик, выбирается по результатам предыдущего теста, это означает, что мы используем исследовательское тестирование.

Главное, что нужно помнить об исследовательском тестировании, это то, что само по себе оно не является методикой тестирования. Это, скорее, подход, который можно применить к любому виду тестирования.


	17. Что такое бизнес – логика?
 
Бизнес – логика (domain) это то, что конкретная программа по задумке должна сделать. Например, в складской программе проверка на возможность отправить товар (вдруг его нет в наличии). 

Это правила, которые должны соблюдаться в данной конкретной программе, определенные бизнес-клиентом. 

Слои приложения – слой пользовательского интерфейса, слой бизнес логики (доменный слой), слой сохранения данных.

	18. Какие существуют основные виды тестирования ПО?

	Функциональные виды («Что?» - проверяет весь функционал продукта):
Функциональное тестирование (Functional testing)
Тестирование взаимодействия (Interoperability testing)

	Нефункциональное («Как?»):
Производительности (Performance)
Тестирование емкости/способностей (Capacity testing)
Стрессовое (Stress testing)
Нагрузочное (Load testing)
Объемное тестирование (Volume testing)
Выносливости (Soak/Endurance testing)
Стабильности/надежности (Stability / Reliability testing)
Шиповое (Spike)
Отказоустойчивости (Stability testing)
Масштабируемости (Scalability test)
Отказ и восстановление (Failover and Recovery testing)
Удобство пользования (Usability testing)
Тестирование установки (Installation testing)
Тестирование безопасности (Security and Access Control testing)
Конфигурационное (Configuration testing)

	Связанное с изменениями:
Регрессионное (Regression testing)
Санитарное (Sanity testing)
Дымовое (Smoke testing)
Тестирование сборки (Build Verification testing)

	Функциональное тестирование рассматривает заранее указанное поведение и основывается на анализе спецификаций функциональности компонента или системы в целом. 
Функциональные тесты основываются на функциях, выполняемых системой, и могут проводиться на всех уровнях тестирования (компонентном, интеграционном, системном, приемочном). 
Как правило, эти функции описываются в требованиях, функциональных спецификациях или в виде случаев использования системы (use cases). 
Тестирование в перспективе «требования» использует спецификацию функциональных требований к системе как основу для дизайна Test case. 
В этом случае необходимо сделать список того, что будет тестироваться, а что нет, приоритезировать требования на основе рисков (если это не сделано в документе с требованиями), а на основе этого приоритезировать тестовые сценарии. 
Это позволит сфокусироваться и не упустить при тестировании наиболее важный функционал. 
Тестирование в перспективе «бизнес-процессы» использует знание этих самых бизнес-процессов, которые описывают сценарии ежедневного использования системы. 
В этой перспективе тестовые сценарии (test scripts), как правило, основываются на случаях использования системы (use cases). 
	Преимущества функционального тестирования:
имитирует фактическое использование системы;
	Недостатки функционального тестирования:
возможность упущения логических ошибок в программном обеспечении;
вероятность избыточного тестирования.

	Тестирование взаимодействия - функциональное тестирование, проверяющее способность приложения/устройства взаимодействовать с одним и более компонентами/системами/устройствами
 и включающее в себя тестирование совместимости (compatibility testing) и интеграционное тестирование (integration testing).  
ПО с хорошими характеристиками взаимодействия может быть легко интегрировано с другими системами, не требуя каких-либо серьезных модификаций. 
В этом случае, количество изменений и время, требуемое на их выполнение, могут быть использованы для измерения возможности взаимодействия. 
Например, тестирование совместимости проводится между смартфонами и планшетами для проверки передачи данных через Bluetooth. 
Существуют разные уровни тестирования совместимости:

Аппаратное обеспечение: проверяет совместимость программного обеспечения с различными аппаратными конфигурациями. 

Операционные системы: Он проверяет ваше программное обеспечение на совместимость с различными операционными системами, такими как Windows, Unix*, Mac OS и т. д. 

Программное обеспечение: проверяет ваше разработанное программное обеспечение на совместимость с другим программным обеспечением. Например, приложение MS Word должно быть совместимо с другими программами, такими как MS Outlook, MS Excel, VBA и т. д. 

Сеть: оценка производительности системы в сети с различными параметрами, такими как пропускная способность, скорость работы, емкость. 

Браузер: проверяет совместимость вашего сайта с различными браузерами, такими как Firefox, Google Chrome, Internet Explorer и т. д. 

Устройства: проверяет совместимость вашего программного обеспечения с различными устройствами, такими как устройства USB-порта, принтеры и сканеры, другие мультимедийные устройства и Bluetooth. 

Mobile: проверка совместимости вашего программного обеспечения с мобильными платформами, такими как Android, iOS и т. д. 

Версии программного обеспечения. Он проверяет совместимость вашего программного приложения с различными версиями программного обеспечения. Например, проверка вашего Microsoft Word на совместимость с Windows 7, Windows 7 SP1, Windows 7 SP2, Windows 7 SP3.

Существует два типа проверки версий:

Тестирование обратной совместимости предназначено для проверки поведения разработанного аппаратного / программного обеспечения с использованием более старых версий аппаратного / программного обеспечения. 

Тестирование прямой совместимости заключается в проверке поведения разработанного аппаратного / программного обеспечения с использованием более новых версий аппаратного / программного обеспечения.


19 Методы тестирования

Тестирование Black-Box
Методика тестирования без каких-либо знаний о внутренней работе приложения называется «черным ящиком». 
Тестер не обращает внимания на архитектуру системы и не имеет доступа к исходному коду. 
Как правило, при выполнении теста с «черным ящиком» тестер будет взаимодействовать с пользовательским интерфейсом системы, предоставляя входные данные и анализируя выходы, не зная, как и где обрабатываются входы.

Тестирование белого ящика
Проверка белого ящика - это подробное исследование внутренней логики и структуры кода. 
Тестирование с использованием белого ящика также называется тестированием стекла или открытым тестированием . 
Чтобы выполнить тестирование белого ящика в приложении, тестер должен знать внутреннюю работу кода.

Тестер должен заглянуть внутрь исходного кода и выяснить, какое устройство / блок кода ведет себя некорректно.

Тестирование серых ящиков
Тестирование на серой коробке - это метод тестирования приложения с ограниченным знанием внутренней работы приложения. 
При тестировании программного обеспечения фраза, чем больше вы знаете, тем лучше переносит массу при тестировании приложения.

Освоение домена системы всегда дает тестеру преимущество над кем-то с ограниченными знаниями домена. 
В отличие от тестирования черного ящика, где тестер тестирует только пользовательский интерфейс приложения; при тестировании в сером полете тестер имеет доступ к проектной документации и базе данных. 
Имея эти знания, тестер может подготовить лучшие тестовые данные и сценарии тестирования при составлении плана тестирования.






