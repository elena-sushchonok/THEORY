	
	1. Что подразумевается под тестовой средой?

Тестовая среда (среда тестирования) — это комбинация аппаратной и программной среды, в которой будут выполняться тесты. Среда поддерживает выполнение теста с настроенным оборудованием, программным обеспечением и сетью.

Тестовая среда (испытательный стенд) настраивается в соответствии с требованиями тестируемого приложения. В некоторых случаях испытательный стенд может представлять собой комбинацию тестовой среды и тестовых данных, которые он использует.

Настройка правильной среды тестирования гарантирует успех тестирования программного обеспечения.

В тестовой среде работают тестировщики. Здесь тестировщики тестируют новые билды, проверяют функционал, проводят регрессионные проверки, воспроизводят ошибки. 

Эта среда появляется во время начала динамического тестирования.

	
	2. В чем отличие build от release?

Билд это номер, даваемый ПО при передаче от разработчиков тестировщикам. Релиз — это номер, даваемый ПО при передаче конечному пользователю.

	
	3. Основные фазы тестирования.

	Основными фазами тестирования являются:

	– модульное тестирование;
	– интеграционное тестирование;
	– системное тестирование (в том числе адаптационное, функциональное и нагрузочное);
	– регрессионное тестирование;
	– приемочное тестирование.

	На стадии модульного тестирования достаточно просто выявляются просчеты в логике построения модуля и/или реализации алгоритмов, ошибки, связанные с неправильным использованием локальных ресурсов, а также ошибки в локальных переменных.

Следующим этапом явлется интеграционное тестирование. Оно проходит в несколько стадий и заключается в тестировании частей системы, состоящих из двух и большего количества модулей. 

	На стадии интеграционного тестирования ошибки управления потоком, ошибки в передаче и/или интерпретации данных, использовании ресурсов, средств коммуникации.

	Третьим этапом является системное тестирование, которое существенным образом отличается от модульного и интеграционного. Оно рассматривает систему как черный ящик и работает исключительно с пользовательскими интерфейсами. 

Основной целью системного тестирования является проверка стабильности и корректности работы системы, а также соответствия функциональностей системы спецификациям, указанным в сопроводительных документах, 

проверяется работа системы на базе различных операционных систем и аппаратного обеспечения. Исследуется производительность тестируемого программного обеспечения.

	Основной целью регрессионного тестирования является проверка того, что в результате внесения изменений в программный код зафиксированные ранее ошибки исправлены, а новые не появляются. 

Для регрессионного тестирования используется специально разработанный набор тестов, из которого каждый раз выбираются те тесты, которые позволяют обнаружить появление новых ошибок с наибольшей вероятностью.

	Приемочное тестирование — тестирование интегральной функциональности системы на соответствие требованиям заказчика. Планируется с участием представителей заказчика. 

Проводится на заключительном этапе с целью удостовериться в том, что система работает так, как и ожидалось, все необходимые формы, процедуры присутствуют и функционируют нормально. 

Данное тестирование является высокоуровневой проверкой отсутствия пробелов в функциональности системы.

Положительные результаты бизнес-тестирования означают, что все компоненты системы работоспособны и включены в данную версию продукта.


	4. Что такое импакт анализ?

Impact Analysis (импакт анализ) - это исследование, которое позволяет указать затронутые места (affected areas) в проекте при разработке новой или изменении старой функциональности, а также определить, насколько значительно они были затронуты. 

Затронутые области требуют большего внимания во время проведения регрессионного тестирования. Импакт анализ может быть полезным в следующих случаях:

 * есть изменения в требованиях;

 * получен запрос на внесение изменений в продукт;

 * ожидается внедрение нового модуля или функциональности в существующий продукт;

 * каждый раз, когда есть изменения в существующих модулях или функциональностях продукта.

	В настоящее время продукты становятся все более большими и комплексными, а компоненты все чаще зависят друг от друга. 

Изменение строчки кода в таком проекте может "сломать" абсолютно все. Информация о взаимосвязи и взаимном влиянии изменений могут помочь QA:

сфокусироваться на тестировании функциональности, где изменения были представлены;

принять во внимание части проекта, которые были затронуты изменениями и, возможно, пострадали;

не тратить время на тестирование тех частей проекта, которые не были затронуты изменениями.

	5. Критерии выбора тестов.

Требования к идеальному критерию тестирования:

Критерий должен быть достаточным, т.е. показывать, когда некоторое конечное множество тестов достаточно для тестирования данной программы.
Критерий должен быть полным, т.е. в случае ошибки должен существовать тест из множества тестов, удовлетворяющих критерию, который раскрывает ошибку.
Критерий должен быть надежным, т.е. любые два множества тестов, удовлетворяющих ему, одновременно должны раскрывать или не раскрывать ошибки программы.
Критерий должен быть легко проверяемым, например вычисляемым на тестах.
Для нетривиальных классов программ в общем случае не существует полного и надежного критерия, зависящего от программ или спецификаций. 
Поэтому мы стремимся к идеальному общему критерию через реальные частные. 
	
Классы критериев:

Структурные критерии используют информацию о структуре программы (критерии так называемого "белого ящика").
Функциональные критерии формулируются в описании требований к программному изделию ( критерии так называемого "черного ящика" ).
Критерии стохастического тестирования формулируются в терминах проверки наличия заданных свойств у тестируемого приложения, средствами проверки некоторой статистической гипотезы.
Мутационные критерии ориентированы на проверку свойств программного изделия на основе подхода Монте-Карло.
Структурные критерии используют модель программы в виде "белого ящика", что предполагает знание исходного текста программы или спецификации программы в виде потокового графа управления. Структурная информация понятна и доступна разработчикам подсистем и модулей приложения, поэтому данный класс критериев часто используется на этапах модульного и интеграционного тестирования (Unit testing, Integration testing). Структурные критерии базируются на основных элементах УГП (Управляющий граф программы), операторах, ветвях и путях.
Условие критерия тестирования команд (критерий С0) - набор тестов в совокупности должен обеспечить прохождение каждой команды не менее одного раза. Это слабый критерий, он, как правило, используется в больших программных системах, где другие критерии применить невозможно.
Условие критерия тестирования ветвей (критерий С1) - набор тестов в совокупности должен обеспечить прохождение каждой ветви не менее одного раза. Это достаточно сильный и при этом экономичный критерий, поскольку множество ветвей в тестируемом приложении конечно и не так уж велико. Данный критерий часто используется в системах автоматизации тестирования.
Условие критерия тестирования путей (критерий С2) - набор тестов в совокупности должен обеспечить прохождение каждого пути не менее 1 раза. Если программа содержит цикл (в особенности с неявно заданным числом итераций), то число итераций ограничивается константой (часто - 2, или числом классов выходных путей).
Структурные критерии не проверяют соответствие спецификации, если оно не отражено в структуре программы. Поэтому при успешном тестировании программы по критерию C2 мы можем не заметить ошибку, связанную с невыполнением некоторых условий спецификации требований. Функциональный критерий - важнейший для программной индустрии критерий тестирования. Он обеспечивает, прежде всего, контроль степени выполнения требований заказчика в программном продукте. Поскольку требования формулируются к продукту в целом, они отражают взаимодействие тестируемого приложения с окружением. При функциональном тестировании преимущественно используется модель "черного ящика". Проблема функционального тестирования - это, прежде всего, трудоемкость; дело в том, что документы, фиксирующие требования к программному изделию (Software requirement specification, Functional specification и т.п.), как правило, достаточно объемны, тем не менее, соответствующая проверка должна быть всеобъемлющей. Ниже приведены частные виды функциональных критериев:
	Тестирование пунктов спецификации - набор тестов в совокупности должен обеспечить проверку каждого тестируемого пункта не менее одного раза. Спецификация требований может содержать сотни и тысячи пунктов требований к программному продукту и каждое из этих требований при тестировании должно быть проверено в соответствии с критерием не менее чем одним тестом.
	Тестирование классов входных данных - набор тестов в совокупности должен обеспечить проверку представителя каждого класса входных данных не менее одного раза. При создании тестов классы входных данных сопоставляются с режимами использования тестируемого компонента или подсистемы приложения, что заметно сокращает варианты перебора, учитываемые при разработке тестовых наборов. Следует заметить, что перебирая в соответствии с критерием величины входных переменных (например, различные файлы - источники входных данных), мы вынуждены применять мощные тестовые наборы. Действительно, наряду с ограничениями на величины входных данных, существуют ограничения на величины входных данных во всевозможных комбинациях, в том числе проверка реакций системы на появление ошибок в значениях или структурах входных данных. Учет этого многообразия - процесс трудоемкий, что создает сложности для применения критерия.
	Тестирование правил - набор тестов в совокупности должен обеспечить проверку каждого правила, если входные и выходные значения описываются набором правил некоторой грамматики. Следует заметить, что грамматика должна быть достаточно простой, чтобы трудоемкость разработки соответствующего набора тестов была реальной (вписывалась в сроки и штат специалистов, выделенных для реализации фазы тестирования).
	Тестирование классов выходных данных - набор тестов в совокупности должен обеспечить проверку представителя каждого выходного класса, при условии, что выходные результаты заранее расклассифицированы, причем отдельные классы результатов учитывают, в том числе, ограничения на ресурсы или на время (time out). При создании тестов классы выходных данных сопоставляются с режимами использования тестируемого компонента или подсистемы, что заметно сокращает варианты перебора, учитываемые при разработке тестовых наборов.
	Тестирование функций - набор тестов в совокупности должен обеспечить проверку каждого действия, реализуемого тестируемым модулем, не менее одного раза. Очень популярный на практике критерий, который, однако, не обеспечивает покрытия части функциональности тестируемого компонента, связанной со структурными и поведенческими свойствами, описание которых не сосредоточено в отдельных функциях (т.е. описание рассредоточено по компоненту). Критерий тестирования функций объединяет отчасти особенности структурных и функциональных критериев. Он базируется на модели "полупрозрачного ящика", где явно указаны не только входы и выходы тестируемого компонента, но также состав и структура используемых методов (функций, процедур) и классов.
	
	Комбинированные критерии для программ и спецификаций - набор тестов в совокупности должен обеспечить проверку всех комбинаций непротиворечивых условий программ и спецификаций не менее одного раза. При этом все комбинации непротиворечивых условий надо подтвердить, а условия противоречий следует обнаружить и ликвидировать.
	
	Стохастическое тестирование применяется при тестировании сложных программных комплексов - когда набор детерминированных тестов (X,Y) имеет громадную мощность. Мутационный критерий (класс IV). Постулируется, что профессиональные программисты пишут сразу почти правильные программы, отличающиеся от правильных мелкими ошибками или описками типа - перестановка местами максимальных значений индексов в описании массивов, ошибки в знаках арифметических операций, занижение или завышение границы цикла на 1 и т.п. Предлагается подход, позволяющий на основе мелких ошибок оценить общее число ошибок, оставшихся в программе. Подход базируется на следующих понятиях: Мутации - мелкие ошибки в программе. Мутанты - программы, отличающиеся друг от друга мутациями . Метод мутационного тестирования - в разрабатываемую программу P вносят мутации, т.е. искусственно создают программы-мутанты P1, P2... Затем программа P и ее мутанты тестируются на одном и том же наборе тестов (X,Y). Если на наборе (X,Y) подтверждается правильность программы P и, кроме того, выявляются все внесенные в программы-мутанты ошибки, то набор тестов (X,Y) соответствует мутационному критерию, а тестируемая программа объявляется правильной. Если некоторые мутанты не выявили всех мутаций, то надо расширять набор тестов (X,Y) и продолжать тестирование.
	
	6. Принципы тестирования

1. Тестирование показывает наличие дефектов

Тестирование может показать наличие дефектов в программе, но не доказать их отсутствие. Тем не менее, важно составлять тест-кейсы, которые будут находить как можно больше багов. Таким образом, при должном тестовом покрытии, тестирование позволяет снизить вероятность наличия дефектов в программном обеспечении. В то же время, даже если дефекты не были найдены в процессе тестирования, нельзя утверждать, что их нет.

2. Исчерпывающее тестирование невозможно

Невозможно провести исчерпывающее тестирование, которое бы покрывало все комбинации пользовательского ввода и состояний системы, за исключениям совсем уж примитивных случаев. Вместо этого необходимо использовать анализ рисков и расстановку приоритетов, что позволит более эффективно распределять усилия по обеспечению качества ПО.

3. Раннее тестирование

Тестирование должно начинаться как можно раньше в жизненном цикле разработки программного обеспечения, и его усилия  должны быть сконцентрированы на определенных целях.

4. Скопление дефектов

Разные модули системы могут содержать разное количество дефектов – то есть, плотность скопления дефектов в разных элементах программы может отличаться. Усилия по тестированию должны распределяться пропорционально фактической плотности дефектов. В основном, большую часть критических дефектов находят в ограниченном количестве модулей. Это проявление принципа Парето: 80% проблем содержатся в 20% модулей.

5. Парадокс пестицида

Прогоняя одни и те же тесты вновь и вновь, Вы столкнетесь с тем, что они находят все меньше новых ошибок. Поскольку система эволюционирует, многие из ранее найденных дефектов исправляют и старые тест-кейсы больше не срабатывают.

Чтобы преодолеть этот парадокс, необходимо периодически вносить изменения в используемые наборы тестов, рецензировать и корректировать их с тем, чтобы они отвечали новому состоянию системы и позволяли находить как можно большее количество дефектов.

6. Тестирование зависит от контекста

Выбор методологии, техники и типа тестирования будет напрямую зависеть от природы самой программы. Например, программное обеспечение для медицинских нужд требует гораздо более строгой и тщательной проверки, чем, скажем, компьютерная игра. Из тех же соображений, сайт с большой посещаемостью должен пройти через серьезное тестирование производительности, чтобы показать возможность работы в условиях высокой нагрузки.

7. Заблуждение об отсутствии ошибок.

Тот факт, что тестирование не обнаружило дефектов, еще не значит, что программа готова к релизу. Нахождение и исправление дефектов будут не важны, если система окажется неудобной в использовании, и не будет удовлетворять ожиданиям и потребностям пользователя.
	
	7. Что такое независимое тестирование?

	Независимое тестирование соответствует независимой команде, которая участвует в тестировании, отличном от разработчика, чтобы избежать предвзятости автора и часто более эффективна в поиске дефектов и сбоев.	

	Иногда следует нанять независимую организацию по тестированию, которая тщательно проверит продукт на наличие сбоев, готовя его к развертыванию.  
	
	Тестирование по уровням независимости:

Программист тестирует свой код 
Тестирование проводится другим программистом в организации
Внутренняя команда тестирования 
Независимая организация тестирования
Когда программист проверяет свой код: Вы бы никогда не попросили шеф-повара быть его собственным критиком. И даже если вы это сделаете, вам будет трудно поверить всему, что он говорит. Смысл - создатель никогда не может быть хорошим критиком своей собственной работы. Программист знает свой код от и до. Их цель - создать продукт и отправить его в кратчайшие сроки. Вместо того, чтобы искать ошибки со всех возможных точек зрения, они будут искушены найти способы обойти найденные ошибки. Писатель Гленфорд Майерс в своей книге «Искусство тестирования программного обеспечения» перечислил разницу в мышлении разработчика и тестировщика. Он сказал, что разработчик думает как строитель, сосредоточенный на строительстве, в то время как тестировщик ищет недостатки, которые приведут к разрушению здания, если не будут решены. 
Тестирование проводится другим программистом в организации: Компромисс - это найти кого-то в организации. Это может быть какой-то другой программист, который участвует в некоторых других проектах. Это дает определенный уровень независимости. Но проблема возникает из-за того же reporting manager. Менеджер может попросить программиста пропустить некоторые тесты, когда есть ограничения по времени. Это приведет к неполному тестированию продукта. Кроме того, если попросить других разработчиков провести тестирование, это приведет к развертыванию различных ресурсов в одном проекте. Это будет вредно для всей работы организации. 
Внутренняя команда тестирования: Наличие другой внутренней команды - это хорошее решение. Но поскольку они будут в организации, на них будут влиять ограничительные сроки. Кроме того, это будет дорого поддерживать внутреннюю команду. Это приведет к большим бюджетным и ресурсным ограничениям для команды. Команда может иметь доступ к ограниченным инструментам и программному обеспечению, таким образом, не отвечая требованиям всех проектов. Среда тестирования также будет варьироваться в зависимости от количества пользователей и числа выполненных интеграций. Затем тестирование будет проводиться в спешном порядке, что приведет к упущению некоторых ошибок, которые могут появиться после выпуска продукта. Решение, которое позаботится обо всех этих недостатках, - «Независимое тестирование». 
Почему независимое тестирование? Независимые тестирующие организации изучат все аспекты вашей продукции. Они работают с мышлением поиска недостатков и ошибок. Они не будут использовать ярлыки в процессе тестирования. И поскольку они не были частью процесса разработки, они будут проводить тесты на нейтральной основе, чтобы прежние интересы не мешали процессу тестирования. Мысль о поиске максимальных «точек останова» пойдет на пользу вашему продукту. Почти все сторонние тестирующие организации предоставят вам подробные отчеты об ошибках и предложат корректирующие меры. 

	8. Что такое тестирование со сдвигом влево?

	В попытке перенести тестирование на более ранний этап жизненного цикла разработки при одновременном улучшении показателей качества, задачи смещаются влево в схеме жизненного цикла разработки ПО. 
По возможности, тестирование должно проводиться с самого начала фазы проектирования, чтобы построить соответствующую стратегию тестирования. 
Проще говоря, это подход к тестированию программного обеспечения и тестированию системы, при котором тестирование выполняется на более раннем этапе жизненного цикла. 

Ключевые преимущества:
	* Сокращение затрат 
	 * Более высокое качество
 	* Повышение эффективности 
 	* Конкурентные преимущества

	9. Почему тестирование делится на отдельные этапы?

	* Каждый этап испытаний имеет свое назначение 
	* Проще управлять поэтапно 
	* Мы можем запустить разные тесты в разных средах 
	* Производительность и качество тестирования улучшаются с помощью поэтапного тестирования

	10. Этапы тестирования.

	Первый этап. Анализ требований

Условия и критерии работы системы, как правило, определяются заказчиком или менеджером проекта в процессе общения с клиентом, или анализом стандартов и нормативной документации. 
Эти требования могут быть как функциональными, так и нефункциональными.

Тестировщик работает над статическим тестированием требований: исследует их полноту, логичность, однозначность и определенность, также находит слабые места в тестовом покрытии и выявляет возможные риски.
Возникают обстоятельства, когда имеющиеся требования не тестируются, но используются на этапе дизайна и разработки. И уже готовый продукт направляется в отдел QA. Тогда количество найденных дефектов, стоимость и масштаб их исправления могут значительно возрасти.

	Второй этап. Процесс дизайна

Один из самых важных составляющих этапов, так как пользователю придется постоянно взаимодействовать с системой. 
Продукт должен быть интуитивно понятен в использовании, иметь приятный интерфейс, а также быть оптимизированным (пользователь совершает минимальные действия для достижения результата).

На данном этапе тестировщик проверяет существующие прототипы ПО на соответствие требованиям заказчика, корректности отображения визуальных элементов и удобства использования.

	Третий этап. Разработка

Во время процесса разработки системы следует провести модульное, интеграционное и системное тестирование. 

Для начала тестируются отдельные компоненты программы. Это позволяет обнаружить, в какой именно части кода есть ошибка и достаточно быстро устранить ее. 
Еще модульное тестирование помогает отследить, не привело ли изменение кода к появлению новых ошибок в уже проверенных местах продукта. 
Также это помогает лучше понять роль каждого модуля системы. Все найденные дефекты, как правило, исправляются в коде без формального их описания (занесения отчетов в баг-трекер).

Интеграционное тестирование позволяет проверить, как компоненты кода объединяются и взаимодействуют друг с другом. Также оно определяет связи между модулями, оборудованием или различными системами.

И, наконец, приступаем к системному тестированию. На этой стадии подразумевается проверка всех компонентов и модулей в целом. 
Это необходимо для уменьшения вероятности дефектов, связанных с особенностями поведения системы в различных окружениях. 
В ходе этих проверок обнаруживаются такие баги, как: нерациональное использование ресурсов системы, несовместимость с окружением, сбой работы или неисправность функционала и т.д.

	Четвертый этап. Процесс тестирования и дебаггинга

Дебаггинг (отладка) – это процесс, во время которого находят и устраняют ошибки программы.

На данном этапе тестировщики проверяют систему на наличие дефектов независимо от того, проводилось ли это ранее. 
Проводится полное тестирование интерфейса и функционала продукта. 
Все обнаруженные ошибки должны быть задокументированы в баг-трекере. 
Также следует провести регрессионное тестирование, чтобы исследовать систему на предмет дефектов, которые могли появиться после устранения других багов. 

По завершению процесса отладки нужно предоставить оценку качества продукта, насколько соответствуют требования заказчика реальной работе системы.

	Пятый этап. Эксплуатация и поддержка

После того, как продукт поступает в релиз, остается необходимость в тестировании, так как будет происходить обновление ПО, будут появляться новые баги, которые были упущены или баги, связанные с эксплуатацией конечного пользователя. 
В таком случае потребуется вмешательство отдела QA.

В случае обнаружения пользователями тех или иных пост-релизных багов, информация о них передается в виде отчетов об ошибках команде разработки, которая, в зависимости от серьезности проблемы, 
либо немедленно выпускает исправление (т.н. hot-fix), либо откладывает его до следующей версии программы.

Все вносимые в программное обеспечение изменения, необходимо тщательно протестировать. 
ПО должно продолжать выполнять изначально заложенные в нем бизнес-функции и не нарушать работоспособность остальных функций и всей системы в целом.

Процесс тестирования ПО охватывает все этапы жизненного цикла разработки. Он непрерывен, продолжителен и требует наличия достаточно опытной команды тестировщиков, чтобы охватить все этапы тестирования. 
А мониторинг и анализ всего процесса помогает спланировать и, в случае необходимости, внести изменения для повышения эффективности дальнейших задач. 
Данная часть современного процесса разработки ПО помогает заказчику, команде разработчиков, и главное, конечному пользователю получить продукт высокого качества.

	11. Как тестировать продукт, если нет требований.	 

	Использование неформальных техник тестирования:

	– Ad hoc тестирование

	– исследовательское (exploratory) тестирование.

Свободное тестирование (ad-hoc testing) – это вид тестирования, который выполняется без подготовки к тестированию продукта, без определения ожидаемых результатов, проектирования тестовых сценариев. 
Это неформальное, импровизационное тестирование. Оно не требует никакой документации, планирования, процессов, которых следует придерживаться при выполнении тестирования. 
Такой способ тестирования в большинстве случаев дает большее количество заведенных отчётов об ошибке.  Это обусловлено тем, что тестировщик на первых шагах приступает к тестированию основной функциональной части продукта и выполняет как позитивные, так и негативные варианты возможных сценариев.

Чаще всего такое тестирование выполняется, когда владелец продукта не обладает конкретными целями, проектной документацией и ранее поставленными задачами. 
При этом тестировщик полагается на свое общее представление о продукте, сравнение с похожими продуктами, собственный опыт. 
Однако при тестировании ad-hoc имеет смысл владеть общей информацией о продукте, особенно если проект очень сложный и большой. 
Поэтому нужно хорошее представление о целях проекта, его назначении и основных функциях и возможностях. А дальше уже можно приступать к ad-hoc тестированию.

Исследовательское тестирование (exploratory testing) — это одновременное изучение программного продукта, проектирование тестов и их выполнение. 
Это неформальный метод проектирования тестов, при котором тестировщик активно контролирует проектирование тестов в то время, как эти тесты выполняются, и использует полученную во время тестирования информацию для проектирования новых тестов.

Если каждый следующий тест, который выполняет тестировщик, выбирается по результатам предыдущего теста, это означает, что мы используем исследовательское тестирование.

Главное, что нужно помнить об исследовательском тестировании, это то, что само по себе оно не является методикой тестирования. 
Это, скорее, подход, который можно применить к любому виду тестирования. 
Еще один важный момент заключается в том, что исследовательское тестирование – это не только выполнение тестов. 
Тестировщики могут применять исследовательский подход и при разработке новых тестов в начале итерации, и при анализе уже завершенных тестов. 
Также, исследовательское тестирование не должно выполняться небрежно, в спешке и без подготовки. 
Исследовательский подход может требовать очень тщательной и длительной подготовки к определенным тестам, а накопленные за многие годы знания и умения тестировщика, применяющего данный подход, – это часто невидимая, но важная форма подготовки. 
Исследовательское тестирование может проводиться вручную, а может осуществляться с широким применением средств автоматизации, т.е. любых вспомогательных инструментов тестирования.

Когда следует применять исследовательское тестирование?

	Самые распространенные случаи:

когда нужно обеспечить быструю обратную связь для нового продукта или новой функциональности продукта;
когда нужно быстро ознакомиться с продуктом;
когда уже были проведены основные виды тестирования и время позволяет разнообразить методы тестирования;
когда нужно найти дефект, локализованный в определенном модуле в кратчайшие сроки;
когда проверяется работа другого специалиста по тестированию;
когда нужно изучить состояние конкретного риска для принятия решения о необходимости покрытия конкретной области  тестами.
Вывод

Описанные выше методы тестирования имеют основательные сходства и различия, поэтому стоит разделять эти две популярные методики в рамках  тестирования. 
Разница между ad-hoc и exploratory testing в том, что теоретически, ad-hoc может провести кто угодно, а для проведения exploratory необходимо мастерство и владение определёнными техниками. 
При этом, определённые техники – это не только техники тестирования.

Оба метода часто используются в проектах, а также являются неотъемлемой частью знаний и опыта современного  тестировщика программного обеспечения.

	12. Как узнать, было ли создано достаточно тестов для тестирования продукта?

Матрица прослеживаемости - это понятный инструмент, который обеспечивает соответствие требований тестовым примерам. 
Когда выполнение всех Test case заканчивается успешно, это указывает на то, что код соответствует требованиям. 

Матрица прослеживаемости - это документ, который связывает любые два базовых документа, которые требуют отношения «многие ко многим» для проверки полноты отношений. 
В случае тестирования это матрица покрытия функциональных требований тест-кейсами. 
Есть даже такое понятие как Requirement based testing, которое имеет место быть, когда есть требования к продукту, на их основе составляются тест-сценарии и выполняется тестирование. 
Зачем нужна эта матрица? 
Например, для того чтобы: - при разработке тестов четко ориентироваться какие из требований уже покрыты тестами, а какие еще нет; - при выполнении тестирования ориентироваться какие из требований прошли все написанные для них тесты успешно, а какие - еще нет. 
Матрица трассировки может служить одновременно в качестве матрицы покрытия. 
Наличие такой матрицы позволяет объективно оценить, какая часть продукта покрыта тестами, а какая нет. 
Это необходимое условие, чтобы оценить, какой объем работы мы уже выполнили и что еще осталось сделать - и по части создания, и по части выполнения тестов. 
Еще одно преимущество traceability matrix – ее наглядность. Если она поддерживается в актуальном состоянии, то можно сразу увидеть "белые пятна" и сосредоточиться на них. 
Traceability matrix также позволяет сравнивать тесты между собой по критерию количества требований, которые они покрывают. 
Одни тесты могут покрывать несколько требований, другие – только одно.

	13. Что подразумевается под тестовыми данными?

	Тестовые данные - это набор входных значений, необходимых для выполнения Test case. Тестировщики определяют данные в соответствии с требованиями. 
	
	Они могут сделать это вручную или использовать инструменты генерации.

	
	14. Что такое бета-тестирование?

	Бета-тестирование - интенсивное использование почти готовой версии продукта (как правило, программного или аппаратного обеспечения) с целью выявления максимального числа ошибок в его работе для их 

последующего устранения перед окончательным выходом продукта на рынок, к массовому потребителю.

	Бета-тестирование предполагает привлечение добровольцев из числа обычных будущих пользователей продукта, которым доступна предварительная версия продукта (так называемая бета-версия).

Такими добровольцами (их называют бета-тестерами) часто движет любопытство к новому продукту — любопытство, ради удовлетворения которого они вполне согласны мириться с возможностью испытать последствия ещё не найденных (а потому и не исправленных) ошибок. Кроме любопытства, мотивация может быть обусловлена желанием повлиять на процесс разработки и в итоге получать более удовлетворяющий их нужды продукт и многим другим.

Кроме того, открытие бета-тестирования может использоваться как часть стратегии продвижения продукта на рынок (например, бесплатная раздача бета-версий позволяет привлечь широкое внимание потребителей к окончательной дорогостоящей версии продукта), а также для получения предварительных отзывов о нём от широкого круга будущих пользователей[1].

Бета-версия не является финальной версией продукта, поэтому разработчик не гарантирует полного отсутствия ошибок, которые могут нарушить работу компьютера и/или привести к потере данных. Хотя и в финальных версиях таких гарантий разработчики, как правило, не дают.

Кроме программного и аппаратного обеспечения понятие бета-версия в последнее время часто применяется к сайтам, либо к их определённым разделам или функциям. При этом в большинстве случаев бета-тестирование является открытым, а доработки производятся в процессе функционирования сайта.


	15. Что означает пилотное тестирование? (Pilot)

	 PILOT testing определяется как тип тестирования программного обеспечения, который проверяет компонент системы или всю систему в режиме реального времени. 
Целью пилотного теста является оценка осуществимости, времени, стоимости, риска и эффективности исследовательского проекта. Это тестирование проводится точно между UAT и Production. 
В пилотном тестировании выбранная группа конечных пользователей пробует тестируемую систему и предоставляет обратную связь до полного развертывания системы. 
Другими словами, это означает проведение генеральной репетиции для последующего теста на удобство использования. Пилотное тестирование помогает в раннем обнаружении ошибок в Системе. 
Пилотное тестирование связано с установкой системы на площадке заказчика (или в среде, моделируемой пользователем) для тестирования на предмет постоянного и регулярного использования. 
Выявленные недостатки затем отправляются команде разработчиков в виде отчетов об ошибках, и эти ошибки исправляются в следующей сборке системы. 
Во время этого процесса иногда приемочное тестирование также включается как часть тестирования на совместимость. Это происходит, когда система разрабатывается для замены старой. 

	17. Что такое бизнес – логика?
 
Бизнес – логика (domain) это то, что конкретная программа по задумке должна сделать. Например, в складской программе проверка на возможность отправить товар (вдруг его нет в наличии). 

Это правила, которые должны соблюдаться в данной конкретной программе, определенные бизнес-клиентом. 

Слои приложения – слой пользовательского интерфейса, слой бизнес логики (доменный слой), слой сохранения данных.

